<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-128265968-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>vain0x&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="A blog.">
<meta property="og:type" content="website">
<meta property="og:title" content="vain0x&#39;s blog">
<meta property="og:url" content="http://vain0x.github.io/blog/page/3/index.html">
<meta property="og:site_name" content="vain0x&#39;s blog">
<meta property="og:description" content="A blog.">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="vain0x&#39;s blog">
<meta name="twitter:description" content="A blog.">
<meta name="twitter:creator" content="@vain0x">
  
    <link rel="alternate" href="/blog/atom.xml" title="vain0x&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog/favicon.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP:400,700&amp;subset=japanese" rel="stylesheet">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">vain0x&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">ブログ</a>
        
          <a class="main-nav-link" href="/blog/archives">記事一覧</a>
        
          <a class="main-nav-link" href="https://note.mu/vain0x/m/m9aa8513f4e97">競プロ参戦記</a>
        
          <a class="main-nav-link" href="https://qiita.com/vain0x">Qiita</a>
        
          <a class="main-nav-link" href="https://github.com/vain0x">GitHub</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSSフィード"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="検索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://vain0x.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-observable-collection-design-notes" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017-03-10/observable-collection-design-notes/" class="article-date">
  <time datetime="2017-03-10T05:42:00.000Z" itemprop="datePublished">2017-03-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017-03-10/observable-collection-design-notes/">観測可能なコレクションの設計考察</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://qiita.com/vain0x/items/772d2a17c7d1cb735dd1" target="_blank" rel="noopener">Qiita</a></p>
<p>WPF 用のコレクションを設計しようとしてぐだぐだ考えた話をします。<a href="https://github.com/DotNetKit/DotNetKit.Reactive/tree/z_observable_list_rwlock" target="_blank" rel="noopener">うまくいかない設計に基づく実装をけっこう書いてしまった</a> ので、その供養でもあります。</p>
<h2 id="背景-WPF-のリストボックス"><a href="#背景-WPF-のリストボックス" class="headerlink" title="背景: WPF のリストボックス"></a>背景: WPF のリストボックス</h2><p><strong>WPF</strong> とは、Windows で動くネイティブ GUI アプリケーションを作成するためのフレームワークの1つです。</p>
<p>WPF ではリストボックスのように複数の項目を含むコントロールを表示する際、バインディングという機能を用いて、次のように実装します。まず ObservableCollection のインスタンスを用意します。これはある機能を持つ、動的なリストです。要素は普通の文字列やオブジェクトでOK。このコレクションを (Binding オブジェクトでラップして) リストボックスの ItemsSource プロパティに設定すると、リストボックスに a, b, c という3つの項目が表示されます。興味深いのはここからで、ObservableCollection に要素を追加・削除すると、リストボックスの対応する項目も連動して追加・削除されるのです。</p>
<p>WPF のリストボックスなどにバインドできるコレクションはなんでもいいですが、項目の連動機能を利用するには一定の条件をクリアする必要があります。その条件を満たすコレクションを、ここでは <strong>観測可能なコレクション</strong> と呼ぶことにします。例に挙げた ObservableCollection は観測可能なコレクションの代表例です。</p>
<p>要素の連動をどうやっているか簡単に説明すると、まず観測可能なコレクションに要素が追加・削除されるたび、それが実装する INotifyCollectionChanged インターフェイスの CollectionChanged イベントが発生します。WPF はこれを購読していて、イベントの内容 (要素 x が i 番目に追加された、など) に合わせてリストボックスを操作します。</p>
<h3 id="マルチスレッド問題"><a href="#マルチスレッド問題" class="headerlink" title="マルチスレッド問題"></a>マルチスレッド問題</h3><p>WPF は 他の GUI ライブラリーと同じように UI スレッドパターンを利用していて、すなわち UI スレッドと呼ばれる単一のスレッドからしか UI 要素を操作できません。</p>
<p>さて、観測可能なコレクションに変更操作が加わるたび、イベントが発生して、WPF がリストボックスの項目を追加・削除するわけですが、イベントの発生とリストボックスの操作は同一のスレッドで行われるようです (※デフォルトの場合)。先述の通り WPF がリストボックスを触れるのは UI スレッドだけなので、観測可能なコレクションの CollectionChanged イベントも UI スレッドで起こさなければいけません。</p>
<p>すべての処理を UI スレッドで行えば話は簡単なのですが、そうは問屋が卸しません。時間のかかる処理を UI スレッド上で実行すると、その間 UI 要素が応答しなくなってしまいます。そのため、時間のかかる処理は非 UI スレッド上で実行するのが普通です。</p>
<p>そういうわけで、WPF アプリケーションではたいてい2つ以上のスレッドが走ります。問題は、複数のスレッドから単一のオブジェクトを操作すると恐怖の競合状態が発生することです。例えば、観測可能なコレクションがスレッド安全でない場合、非 UI スレッドでそれを変更するのと同時に UI スレッドからアクセスがあったとしたら、そこで競合状態になります。</p>
<p>ここに3つの選択肢があります。</p>
<ul>
<li>(A) 観測可能なコレクションの操作はすべて UI スレッドで行う。</li>
<li>(B) 観測可能なコレクションをスレッド安全にする。</li>
<li>(C) スレッド安全ではないが競合は起きない方法をとる。(後述)</li>
</ul>
<p>(A) を選べば万事解決ですが、人間はめんどうくさがるものです。コレクションを操作するのにいちいち UI スレッドへのディスパッチを行うのはめんどうです。(C) は思いつきもしなかったので、筆者は (B) を選ぼうとしました。</p>
<p>ここからが本題です。</p>
<h2 id="B-案-スレッド安全な観測可能コレクション"><a href="#B-案-スレッド安全な観測可能コレクション" class="headerlink" title="(B)案: スレッド安全な観測可能コレクション"></a>(B)案: スレッド安全な観測可能コレクション</h2><p>観測可能なコレクションをスレッド安全にする方法は、筆者が思いつくかぎりでは4つほどあります。</p>
<h3 id="方法1-スレッドによる所有"><a href="#方法1-スレッドによる所有" class="headerlink" title="方法1: スレッドによる所有"></a>方法1: スレッドによる所有</h3><p>観測可能なコレクションの代表例である ObservableCollection は、スレッド安全なコレクションです (※)。どのくらい安全かというと、<strong>非UIスレッドから操作すると例外が送出される</strong> のです。実にあんしんです。</p>
<p>これすなわち、変更操作をするたびに UI スレッドへのディスパッチが必要ということです。さきほどの (A) 案と一緒ですね。</p>
<p>※ここで、コレクションがスレッド安全であるとは、それに対して少なくとも1つの変更操作を含む複数の操作が同時に実行されたとしても競合状態を引き起こさないこと、と定義しておきます。ObservableCollection は1つのスレッドからしか触れませんから、競合状態を引き起こすことはありません。ゆえにスレッド安全となります。</p>
<h3 id="方法2-排他ロック"><a href="#方法2-排他ロック" class="headerlink" title="方法2: 排他ロック"></a>方法2: 排他ロック</h3><p>スレッド安全性といえば排他ロックでしょう。排他ロックそのものの説明は割愛します。</p>
<p>初め、筆者はこの方針で観測可能なコレクションを実装したのですが、スレッド安全性の保証で行き詰まりました。というのも、外部に晒したコレクションをロックで守るのがそもそも不可能だったのです。</p>
<p>例えば、 <code>Enumerable.ToArray</code> 拡張メソッドの実装はだいたいこんな感じになっているはずです:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> X[] ToArray&lt;X&gt;(IEnumerable&lt;X&gt; xs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> list = xs <span class="keyword">as</span> IList&lt;X&gt;;</span><br><span class="line">    <span class="keyword">if</span> (list != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> array = <span class="keyword">new</span> X[list.Count];</span><br><span class="line">        list.CopyTo(array, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 以下略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>こういう「リストの Count を参照した後、その値を利用して別の操作をする」みたいな処理では、Count から後続の処理までの間に要素数が変わらないようにする必要がありますが、ToArray がロックをとってくれていないのでそれは不可能です。</p>
<p>書いたコードはお焚きあげに出しました。 R.I.P.</p>
<h3 id="方法3-コレクション系インターフェイスを実装しない"><a href="#方法3-コレクション系インターフェイスを実装しない" class="headerlink" title="方法3. コレクション系インターフェイスを実装しない"></a>方法3. コレクション系インターフェイスを実装しない</h3><p>先ほどの ToArray 問題の原因は、<code>IList&lt;_&gt;</code> などのコレクション系インターフェイスが並行プログラミングをサポートしていないことにあります。そこで、それらのインターフェイスを捨てて、<code>IEnumerable&lt;_&gt;</code> だけを実装するようにすれば安全です。</p>
<h4 id="GetEnumerator-の非効率性"><a href="#GetEnumerator-の非効率性" class="headerlink" title="GetEnumerator の非効率性"></a>GetEnumerator の非効率性</h4><p>この選択肢の利点と欠点を考えましょう。1つ目の欠点は、LINQ to IEnumerable が使えなくなることです。というのも、先述の <code>Enumerable.ToArray</code> は、渡されたシーケンス (IEnumerable) の実体の型がコレクションかどうかで条件分岐しています。コレクションでなければ Count などを参照できないので、GetEnumerator だけを使って処理を行います。一般的にシーケンスに対する GetEnumerator だけを使う実装は、著しく非効率な場合があります。例えば <code>Enumerable.Count</code> (シーケンスの長さを取得する) のように、コレクションであれば一瞬で実行できるはずの操作にも要素の数だけ時間がかかることになります。</p>
<p>しかしこの欠点にはいちおうの対策があります。というのも、拡張メソッドはオーバーライドできませんが、シャドーイングはできるからです。そのため、<code>Enumerable.Count</code> のように効率の悪くなるメソッドに対して観測可能なコレクション用に特化したメソッドを用意しておくことで、ある程度の問題は解決します。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 読み取り専用の観測可能なコレクションを表すインターフェイスを定義しておく。</span></span><br><span class="line">public interface IReadOnlyObservableList&lt;T&gt;</span><br><span class="line">    : IEnumerable&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Task&lt;<span class="keyword">int</span>&gt; <span class="title">CountAsync</span>(<span class="params"></span>)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 観測可能なコレクションに特化した拡張メソッドを定義しておく。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ObservableListExtension</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> Count&lt;X&gt;(<span class="keyword">this</span> IReadOnlyObservableList&lt;X&gt; @<span class="keyword">this</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> @<span class="keyword">this</span>.CountAsync().Result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 効率のよい方のメソッドが使われる。</span></span><br><span class="line"><span class="keyword">new</span> MyObservableList&lt;<span class="keyword">int</span>&gt;().Count();</span><br></pre></td></tr></table></figure>
<p>対象は Count(), Any(), ElementAt(int), Last() です。このくらいなら実装量的にも大丈夫でしょう。</p>
<p>もちろん WPF は特化版のメソッドを使ってはくれませんが、WPF がコレクションの要素数を取得したりインデックスでアクセスしたりする場面が思いつかないので (あったら教えてください)、ひとまず問題なしとします。</p>
<h4 id="スレッド安全性の確保"><a href="#スレッド安全性の確保" class="headerlink" title="スレッド安全性の確保"></a>スレッド安全性の確保</h4><p>標準のコレクション系インターフェイスを実装しないだけでは、まだスレッド安全になりません。UI スレッドから GetEnumerator が起動されることになるので、GetEnumerator と他の操作が同時に起動されても大丈夫なようにする (あるいは同時には起動されないようにする) 必要があります。</p>
<p>これは比較的簡単にできます。例えば排他ロックを用いて、GetEnumerator を「ロックの中でリスト全体のコピーを作り、そのコピーの列挙子を返す」ようにする、などです。これは次のような実装になります。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// コレクションの要素を入れておくリスト</span></span><br><span class="line"><span class="keyword">readonly</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ロックオブジェクト</span></span><br><span class="line"><span class="keyword">readonly</span> <span class="keyword">object</span> gate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> X Invoke&lt;X&gt;(Func&lt;X&gt; f)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">lock</span> (gate)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> f();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> IEnumerator&lt;T&gt; <span class="title">GetEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Invoke(() =&gt; list.ToList()).GetEnumerator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考えられる方法としては:</p>
<ul>
<li>排他ロック &amp; コピー</li>
<li>単一スレッドへのディスパッチ &amp; コピー</li>
<li>不変オブジェクト</li>
</ul>
<p>などがあります。詳細は割愛。</p>
<h4 id="コレクション操作のインターフェイス"><a href="#コレクション操作のインターフェイス" class="headerlink" title="コレクション操作のインターフェイス"></a>コレクション操作のインターフェイス</h4><p>標準のコレクション系インターフェイスを実装しないということは、コレクションに対する挿入や除去の操作を独自に提供する必要があります。</p>
<p>単純に <code>IList&lt;_&gt;</code> と同じインターフェイスを提供するのが自然です。</p>
<p>スレッド安全性の保証に単一スレッドへのディスパッチを用いるのであれば、結果を Task として返すような非同期操作を持たせるのもありでしょう。</p>
<h4 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h4><ul>
<li>利点: スレッド安全性を獲得できる。</li>
<li>欠点: 外法。</li>
</ul>
<h3 id="方法4-単一スレッドへのディスパッチ"><a href="#方法4-単一スレッドへのディスパッチ" class="headerlink" title="方法4. 単一スレッドへのディスパッチ"></a>方法4. 単一スレッドへのディスパッチ</h3><p>スレッド安全なコレクションを考える話に戻ります。</p>
<p>次の方法は、コレクションへの変更を書き込む処理と、コレクションからデータを読み取る処理をすべて単一のスレッドで行う、というものです。すなわち、ある単一のスレッドではコレクションを普通に操作する代わり、それとは別のスレッドから操作しようとしたら、その単一のスレッドにコレクションへの操作を「依頼」する、ということです。ちなみに他のスレッドに処理を依頼することをディスパッチするというみたいです。</p>
<p>この方法ではディスパッチ処理をコレクションの内部 (Add メソッドなど) で行うので、使う側はめんどくさくありません。</p>
<p>スレッドの切り替えには、標準にある System.Threading.SynchronizationContext を使えばよいでしょう。WPF にある Dispatcher を使うという手もありますが、これは高機能すぎますし、sealed class なのでテストダブルが作れないという問題と、ライブラリーに対する依存関係が深くなる問題があるので、ひとまず置いておきます。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ObservableList&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">readonly</span> SynchronizationContext context =</span><br><span class="line">        SynchronizationContext.Current;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">readonly</span> List&lt;T&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">T <span class="keyword">value</span></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        context.Send(state =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// ここは UI スレッドで行われる。</span></span><br><span class="line">            list.Add(<span class="keyword">value</span>);</span><br><span class="line">        &#125;, <span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>この方法では、先述の ToArray 問題が解決できません。</p>
<h2 id="C-案-UI-非UIスレッド間のスレッド安全性保証"><a href="#C-案-UI-非UIスレッド間のスレッド安全性保証" class="headerlink" title="(C)案: UI/非UIスレッド間のスレッド安全性保証"></a>(C)案: UI/非UIスレッド間のスレッド安全性保証</h2><p>コレクション自体をスレッド安全にするのではなく、ユーザーと WPF からの同時アクセスだけを防ぐ方針もありえます。その2つがどう違うのかというと、後者の場合は例えばユーザーが2つの非UIスレッドを作って、それらから単一のコレクションを同時に操作したときに、競合状態が起きうるということです。ただし、ユーザーがコレクションを操作しているのと同時に WPF (UI スレッド) がコレクションにアクセスしても、競合状態は起こりません。</p>
<p>そもそもの目的を思い出すと、たしかにユーザーサイドでの同時アクセスまで面倒をみる必要はないように思えます。</p>
<h3 id="EnableCollectionSynchronization"><a href="#EnableCollectionSynchronization" class="headerlink" title="EnableCollectionSynchronization"></a>EnableCollectionSynchronization</h3><p>実際にどうやるかというと、WPF が提供している BindingOperations.EnableCollectionSynchronization メソッドを使います。このメソッドをあらかじめコレクションに適用しておくことで、観測可能なコレクションを非UIスレッドから更新しても安全になるそうです。</p>
<h3 id="所有スレッドの変更"><a href="#所有スレッドの変更" class="headerlink" title="所有スレッドの変更"></a>所有スレッドの変更</h3><p>これは筆者の経験に基づく憶測なのですが、ビューモデルの一生は2ステップに分かれます。1つはビューモデルのコンストラクターの内部で、データベースなどから取ってきた値にもとづいてコレクションなどに初期値を入れていく過程です。2つ目は、ビューモデルを UI 要素のプロパティにバインドして、ユーザーの操作のフィードバックを受ける過程です。</p>
<p>ビューモデルの生成をUIスレッドでやるか非UIスレッドでやるかという考察は、それだけで記事が1つ書けるぐらいの内容だと思いますが、ここでは非UIスレッドでやると仮定します。その場合、観測可能なコレクションが生成されるのは非UIスレッドです。1つ目の過程 (初期値を入れていく) は、まだ UI 要素にバインドされていないので、非UIスレッドで行っても問題ありません。しかし2つ目の過程 (ユーザーの操作のフィードバックを受ける) は、もちろん UI スレッドで行う必要があります。</p>
<p>観測可能なコレクションを所有するスレッドを動的に変更するのはどうか、というアイディアです。すなわち、第1過程では生成スレッド (非UIスレッド) に所有され、第2過程に移った段階で UI スレッドに所有されるようにする、ということです。</p>
<p>スレッドの所有権を明示的にプログラムの中で表現しようとすると、委譲処理をどうやって起動するかが問題になります。委譲を行うタイミングは UI 要素にバインドされた瞬間ですが、これをフックする方法が分かりません。この方法は <del>もうめんどくさいのでかんがえたくない</del> さらなる検討の余地がありそうです。</p>
<p>スレッドの所有権をプログラムで表現しない、すなわち「オブジェクトが特に制御しなくても操作元のスレッドが常に1つに限定されるように努力する」というのも1つの方法です。先述の2過程仮説が正しければ、次のような制約でコーディングすれば競合は回避できます: 観測可能コレクションは、それを所有するオブジェクトのコンストラクター、または UI スレッドでのみ操作できる。</p>
<p>これはけっこう現実的で、例えば <a href="https://github.com/runceel/ReactiveProperty" target="_blank" rel="noopener">ReactiveProperty</a> が提供する観測可能なコレクションである ReactiveCollection は、そういう感じの使い方を想定しているようにみえます (※個人の感想です)。</p>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><ul>
<li>ReactiveProperty をインストールしているなら、ReactiveCollection を使おう。</li>
<li>.NET 4.5 以上なら、EnableCollectionSynchronization を使おう。</li>
</ul>
<p>本稿では、ぐだぐだな考察と考慮漏れだらけの迷走を経て、ReactiveCollection がなぜ安全に運用できているのかに対する納得できる仮説を得られた。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li>ugaya40 (2015)「StatefulModelについて」, the sea of fertility. <a href="http://ugaya40.hateblo.jp/entry/StatefulModel" target="_blank" rel="noopener">http://ugaya40.hateblo.jp/entry/StatefulModel</a>, (閲覧日: 2017年3月10日)</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2017-03-10/observable-collection-design-notes/" data-id="cjnspsyyq0033kfcx6rlw6fk1" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/WPF/">WPF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/非同期/">非同期</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-breakable-loop-in-fsharp" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017-03-05/breakable-loop-in-fsharp/" class="article-date">
  <time datetime="2017-03-04T15:00:00.000Z" itemprop="datePublished">2017-03-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017-03-05/breakable-loop-in-fsharp/">break可能なループを書こう - 関数型プログラミングのテクニック</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://qiita.com/vain0x/items/ddef84e3959dffe6a88d" target="_blank" rel="noopener">Qiita</a></p>
<p>手続き型言語を使う人に「F# のループ (for/while) は <code>break</code> できない」というと驚かれるかもしれません。筆者は驚きました。途中で終了する可能性のあるループを書けなくて困りそうですが、その心配は不要です。F# では <strong>末尾再帰関数</strong> を使って、<code>break</code> や <code>continue</code> のあるループと同じことができるからです。</p>
<h2 id="例1-無条件の無限ループ"><a href="#例1-無条件の無限ループ" class="headerlink" title="例1: 無条件の無限ループ"></a>例1: 無条件の無限ループ</h2><p>まずは最も簡単な例を挙げます。<code>break</code> も <code>continue</code> も使わないループを、末尾再帰関数を使って書いてみましょう。ひたすら <code>yes</code> を出力するだけの、通称 yes コマンドです。C# だとこうですね。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">YesAll</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"yes"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>これなら F# の <code>while</code> でも同様に書けますが、練習のため末尾再帰で書いてみましょう。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> yesAll () =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> loop () =</span><br><span class="line">        Console.WriteLine(<span class="string">"yes"</span>)</span><br><span class="line">        loop ()</span><br><span class="line">    loop ()</span><br></pre></td></tr></table></figure>
<p>コードの説明をします。冒頭の <code>let yesAll () = ...</code> は関数の定義で、残りの部分がその本体です。<code>let rec loop () = ...</code> も関数の定義ですが (関数の中に関数！)、<code>rec</code> キーワードがついているので <code>loop</code> 関数は再帰的(<strong>rec</strong>ursive)です (再帰的な関数については後述)。</p>
<p>F# は字下げに依存した構文を採用しています。<code>loop</code> 関数の定義は、字下げが <code>let</code> と同じ深さに戻ったところで終わります。すなわち、<code>loop</code> の本体は2行からなり、字下げの減っている最後の <code>loop ()</code> は含まれません。</p>
<p><code>loop</code> 関数の定義の後ろにある <code>loop ()</code> は、事実上 <code>yesAll</code> が最初に実行する式ですが、単に loop 関数を起動するだけです。</p>
<p>再帰についてもう少し解説します。<code>loop</code> の本体は「yes を出力する」式と「loop を起動する」式の2つからなります。loop の中で loop を起動すると、また「yes を出力する」と「loop を起動する」を実行することになります。すなわち、</p>
<pre><code>loop を起動する
= yes を出力して、次に loop を起動する
= yes を出力して、次に yes を出力して、次に loop を起動する
= yes を出力して、次に yes を出力して、次に yes を出力して、次に loop を起動する
= ……
</code></pre><p>という計算になります。無限ループですね。実際、これは C# で書いたものとほぼ同じループにコンパイルされるはずです。</p>
<h3 id="機械的翻訳"><a href="#機械的翻訳" class="headerlink" title="機械的翻訳"></a>機械的翻訳</h3><p>C# の視点から loop 関数を解釈する手段を紹介します。まず C# のコードのうち、<code>while</code> の「末尾」に到達する部分に <code>continue</code> を挿入します。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">YesAll</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"yes"</span>); <span class="comment">// body</span></span><br><span class="line">        <span class="keyword">continue</span>; <span class="comment">// 追加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>そして、一定の規則で F# のコードに変換します。</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> yesAll () =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> loop () =            <span class="comment">// while (true) &#123;</span></span><br><span class="line">        Console.WriteLine(<span class="string">"yes"</span>) <span class="comment">//   body</span></span><br><span class="line">        loop ()                  <span class="comment">//   continue;</span></span><br><span class="line">    loop ()                      <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p>つまり、 <code>while (true) { ... }</code> を</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">rec</span> loop =</span><br><span class="line">    ...</span><br><span class="line">loop()</span><br></pre></td></tr></table></figure>
<p>に置き換え、ループの本体のうち <code>continue</code> を <code>loop ()</code> に置き換えました。</p>
<p>こうして簡単に末尾再帰バージョンを手に入れることができます。</p>
<h2 id="例2-停止する無限ループ"><a href="#例2-停止する無限ループ" class="headerlink" title="例2: 停止する無限ループ"></a>例2: 停止する無限ループ</h2><p>先ほどの例で基本的な考え方を会得したので、<code>break</code> を使うループの例を見ていきましょう。</p>
<p>以下の関数は、標準入力から行を読み込むたびに「叫ぶ」(大文字に変換して出力する)ものです。入力を読み切ったら自動的に終了することにします。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ScreamLine</span>(<span class="params"><span class="keyword">string</span> line</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Console.WriteLine(line.ToUpper() + <span class="string">"!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Scream</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 標準入力から1行を取得する。</span></span><br><span class="line">        <span class="comment">// 入力の終端に到達していたら、null が返る。</span></span><br><span class="line">        <span class="keyword">var</span> line = Console.ReadLine();</span><br><span class="line">        <span class="keyword">if</span> (line == <span class="literal">null</span>) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        ScreamLine(line);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>これを少しだけ変形します。<code>if</code> 文には常に <code>else</code> をつけ、末尾に到達する部分に <code>continue</code> を挿入します。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Run</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> line = Console.ReadLine();</span><br><span class="line">        <span class="keyword">if</span> (line == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ScreamLine(line);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>そして、前述の変換に加えて <code>break</code> を <code>()</code> に置き換えると完成です：</p>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> screamLine (line: string) =</span><br><span class="line">    Console.WriteLine(line.ToUpper() + <span class="string">"!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scream () =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> loop () =                   <span class="comment">// while (true) &#123;</span></span><br><span class="line">        <span class="keyword">let</span> line = Console.ReadLine()   <span class="comment">//   var line = ...;</span></span><br><span class="line">        <span class="keyword">if</span> line = <span class="keyword">null</span> <span class="keyword">then</span>             <span class="comment">//   if (line == null) &#123;</span></span><br><span class="line">            ()                          <span class="comment">//     break;</span></span><br><span class="line">        <span class="keyword">else</span>                            <span class="comment">//   &#125; else &#123;</span></span><br><span class="line">            scream line                 <span class="comment">//     ...;</span></span><br><span class="line">            loop ()                     <span class="comment">//     continue;</span></span><br><span class="line">                                        <span class="comment">//   &#125;</span></span><br><span class="line">    loop ()                             <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>()</code> と <code>break</code> が対応することのイメージが分からないと思いますが、直接的な対応はないので、 <code>scream ()</code> の挙動を説明します。</p>
<p>この関数を <code>scream ()</code> のように起動すると、先程の <code>yesAll ()</code> と同じく <code>loop ()</code> が開始します。<code>loop</code> の結果は、読み取った行が <code>null</code> なら (= 入力が終了したら) <code>()</code> (ユニットという名前の定数) で、そうでなければ <code>else</code> 節の値になります。<code>else</code> 節では、入力を叫んだあとループをやり直しますが、yes コマンドとは違っていつかは入力が終わり <code>()</code> が返ってきます。結局、標準入出力の副作用を除けば</p>
<pre><code>scream ()
= loop ()
= ...
= loop ()
= ()
</code></pre><p>となります。<code>()</code> という「ループを伸ばさない式」のおかげで <code>loop</code> の連鎖が切れて、つまりループが終了して (<code>break</code> して) いますね。</p>
<p>C# ではループを続けるのに <code>continue</code> は書かなくていい代わりに、終わらせるときに <code>break</code> を書きます。一方この末尾再帰関数のやりかたでは、ループを終わらせるのに <code>break</code> は書かなくていい代わりに、続けるときに <code>loop ()</code> を書くのです。</p>
<h2 id="例3-有限回のループ"><a href="#例3-有限回のループ" class="headerlink" title="例3: 有限回のループ"></a>例3: 有限回のループ</h2><p>前の2つの例の <code>loop</code> 関数は、引数として <code>()</code> を受け取りましたが、実際は任意の引数が使えます。ループの「状態」を引数で持ち運ぶのはよくあることです。</p>
<p>最後の例は、リストの各要素を1行ずつ表示していくループです。 F# だと <code>for</code> で書けますが、練習のため末尾再帰関数で書きます。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> PrintList&lt;X&gt;(IReadOnlyList&lt;X&gt; list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; list.Count)</span><br><span class="line">    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"&#123;0&#125;"</span>, list[index]);</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>今回は <code>while</code> にガード節がありますが、これは <code>if</code> と <code>break</code> に簡単に分解できて、次のように変形できます：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> PrintList&lt;X&gt;(IReadOnlyList&lt;X&gt; list)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; list.Count) <span class="comment">// 条件節</span></span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;"</span>, list[index]);</span><br><span class="line">            index++;</span><br><span class="line">            <span class="keyword">continue</span>; <span class="comment">// 追加</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 条件不成立 (index &gt;= list.Count) なら終了。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// F#</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> printList (list: IReadOnlyList&lt;_&gt;) =</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">rec</span> loop index =                           <span class="comment">// while (true) &#123;</span></span><br><span class="line">        <span class="keyword">if</span> index &lt; list.Count <span class="keyword">then</span>                 <span class="comment">//    if (...) &#123;</span></span><br><span class="line">            Console.WriteLine(<span class="string">"&#123;0&#125;"</span>, list.[index]) <span class="comment">//      ...;</span></span><br><span class="line">            loop (index + <span class="number">1</span>)                       <span class="comment">//      continue;</span></span><br><span class="line">        <span class="keyword">else</span>                                       <span class="comment">//    &#125; else &#123;</span></span><br><span class="line">            ()                                     <span class="comment">//      break;</span></span><br><span class="line">                                                   <span class="comment">//    &#125;</span></span><br><span class="line">    loop <span class="number">0</span>                                         <span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure>
<p><code>loop</code> 関数の実行を簡単に追ってみましょう。<code>list</code> を長さ 3 のリストとすると、</p>
<pre><code>loop 0
= 0 &lt; 3 なら、出力して loop 1
= loop 1
= 1 &lt; 3 なら、出力して loop 2
= loop 2
= 2 &lt; 3 なら、出力して loop 3
= loop 3
= 3 &lt; 3 なら、出力して loop 4
= (なにもしない)
= ()
</code></pre><p>となります。</p>
<h2 id="まとめ-変換規則"><a href="#まとめ-変換規則" class="headerlink" title="まとめ: 変換規則"></a>まとめ: 変換規則</h2><ol>
<li><code>for</code> や <code>foreach</code> は <code>while</code> に書き換える。</li>
<li><code>while</code> の条件があれば、 <code>while (true)</code> にする代わりに <code>if (! 条件) break;</code> を挿入する。</li>
<li>すべての <code>if</code> 文に <code>else</code> 節を補う。</li>
<li><code>while</code> の末尾に到達する部分に <code>continue</code> を補う。</li>
<li><code>break</code> を <code>()</code> にする。</li>
</ol>
<h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>本稿では、C# のループを比較的単純に末尾再帰関数に変換できることを紹介しました。実際のところ、再帰は再帰として理解したほうがいいと思いますが、こういう小手先のテクニックを用いて理解を深めていくのも1つの手かもしれません。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2017-03-05/breakable-loop-in-fsharp/" data-id="cjnspsyyc002bkfcxngzw43tw" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/F/">F#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/関数型プログラミング/">関数型プログラミング</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-friends-lang" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2017-02-12/friends-lang/" class="article-date">
  <time datetime="2017-02-11T15:00:00.000Z" itemprop="datePublished">2017-02-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2017-02-12/friends-lang/">すごーい！ きみはプログラミング言語を実装できるフレンズなんだね</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://qiita.com/vain0x/items/6d3b75f667d3ec7f1d2a" target="_blank" rel="noopener">Qiita</a></p>
<p>ジャパリパークのみんなー！ フレンズのためのプログラミング言語ができたよー！</p>
<h2 id="サンプルコード"><a href="#サンプルコード" class="headerlink" title="サンプルコード"></a>サンプルコード</h2><h3 id="Socrates"><a href="#Socrates" class="headerlink" title="Socrates"></a>Socrates</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ かばんちゃん は ヒトの フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">すごーい！ あなた が ヒトの フレンズ なら</span><br><span class="line">あなた は しっぽのない フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">だれ が しっぽのない フレンズ なんだっけ？</span><br></pre></td></tr></table></figure>
<p>出力:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">「だれ」は「かばんちゃん」、</span><br><span class="line">あってる？ (y/n)y</span><br><span class="line">やったー！</span><br></pre></td></tr></table></figure>
<p>「かばんちゃん は ヒトの フレンズ」で「ヒトの フレンズ は しっぽのない フレンズ」だから「かばんちゃん は しっぽのない フレンズ」なんだね！</p>
<p>たーのしー！</p>
<h3 id="FizzBuzz"><a href="#FizzBuzz" class="headerlink" title="FizzBuzz"></a>FizzBuzz</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ 0 は 自然数の フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が 自然数の フレンズ なら</span><br><span class="line">きみ の 次 も 自然数の フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">すごーい！ 0 は 3の倍数の フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が 3の倍数の フレンズ なら</span><br><span class="line">きみ の 次 の 次 の 次 も 3の倍数の フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">すごーい！ 0 は 5の倍数の フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が 5の倍数の フレンズ なら</span><br><span class="line">きみ の 次 の 次 の 次 の 次 の 次 も 5の倍数の フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">すごーい！ 0 は 15の倍数の フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が 15の倍数の フレンズ なら</span><br><span class="line">きみ の 次 の 次 の 次 の 次 の 次 の 次 の 次 の</span><br><span class="line">次 の 次 の 次 の 次 の 次 の 次 の 次 の 次 も</span><br><span class="line">15の倍数の フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">すごーい！ きみ が 15の倍数の フレンズ なら</span><br><span class="line">きみ と FizzBuzz は FizzBuzz フレンズ なんだね！ たーのしー！</span><br><span class="line">すごーい！ きみ が 3の倍数の フレンズ なら</span><br><span class="line">きみ と Fizz は FizzBuzz フレンズ なんだね！ たーのしー！</span><br><span class="line">すごーい！ きみ が 5の倍数の フレンズ なら</span><br><span class="line">きみ と Buzz は FizzBuzz フレンズ なんだね！ たーのしー！</span><br><span class="line">すごーい！ きみ が 自然数の フレンズ なら</span><br><span class="line">きみ と きみ は FizzBuzz フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">すごーい！ 0 は きみ の 次 より 小さい フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が かのじょ より 小さい フレンズ なら</span><br><span class="line">きみ の 次 は かのじょ の 次 より 小さい フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">すごーい！ きみ が かのじょ より 小さい フレンズ なら</span><br><span class="line">きみ が きみ と かのじょ との 間の フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が かのじょ より 小さい フレンズ で</span><br><span class="line">かれ が きみ の 次 と かのじょ との 間の フレンズ なら</span><br><span class="line">かれ も きみ と かのじょ との 間の フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">それ が 0 と 16 との 間の フレンズ で</span><br><span class="line">それ と だれ が FizzBuzz フレンズ なんだっけ？</span><br></pre></td></tr></table></figure>
<p>出力:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">「それ」は0、</span><br><span class="line">「だれ」は「FizzBuzz」、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は1、</span><br><span class="line">「だれ」は1、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は2、</span><br><span class="line">「だれ」は2、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は3、</span><br><span class="line">「だれ」は「Fizz」、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は4、</span><br><span class="line">「だれ」は4、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は5、</span><br><span class="line">「だれ」は「Buzz」、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は6、</span><br><span class="line">「だれ」は「Fizz」、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は7、</span><br><span class="line">「だれ」は7、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は8、</span><br><span class="line">「だれ」は8、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は9、</span><br><span class="line">「だれ」は「Fizz」、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は10、</span><br><span class="line">「だれ」は「Buzz」、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は11、</span><br><span class="line">「だれ」は11、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は12、</span><br><span class="line">「だれ」は「Fizz」、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は13、</span><br><span class="line">「だれ」は13、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は14、</span><br><span class="line">「だれ」は14、</span><br><span class="line">あってる？ (y/n)n</span><br><span class="line">---------------</span><br><span class="line">「それ」は15、</span><br><span class="line">「だれ」は「FizzBuzz」、</span><br><span class="line">あってる？ (y/n)y</span><br><span class="line">やったー！</span><br></pre></td></tr></table></figure>
<p>わー！ すごーい！</p>
<h2 id="解説"><a href="#解説" class="headerlink" title="解説"></a>解説</h2><p>Qiita なので技術的な話をします。</p>
<p>処理系のソースコードは <a href="https://github.com/vain0x/friends-lang" target="_blank" rel="noopener">GitHub</a> にあります。</p>
<h3 id="すごーい！-文"><a href="#すごーい！-文" class="headerlink" title="すごーい！ 文"></a>すごーい！ 文</h3><p>「すごーい！」で始まる文は、事実を表明するものです。例えば、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ かばんちゃん は ヒトの フレンズ なんだね！</span><br></pre></td></tr></table></figure>
<p>は命題「かばんちゃん は ヒトの フレンズ」が真であることを表明します。ここで「かばんちゃん」という単語は定義されていませんが、アトムという文字列のようなものなので、使用することができます。</p>
<p>「ヒトの」は述語の名前です。</p>
<h3 id="なんだっけ？-文"><a href="#なんだっけ？-文" class="headerlink" title="なんだっけ？ 文"></a>なんだっけ？ 文</h3><p>「なんだっけ？」で終わる文は、「すごーい！」文で表明した事実を用いて、指定された命題を真にするような割り当てが存在するかを探索します。例えば、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">だれ が ヒトの フレンズ なんだっけ？</span><br></pre></td></tr></table></figure>
<p>と問いかけると、変数「だれ」 <a href="変数は、「だれ」や「あなた」などのいくつかの予約語と、アンダーバーで始まる名前の識別子です。それ以外の識別子はアトムになります。">^var_naming</a> に適当なアトムを代入することで、命題「だれ が ヒトの フレンズ」を真にできるかどうかを判定し、命題を真にするような変数への割り当てを出力します。この例では、「ヒトの フレンズ」述語に関する真偽は、前述のすごーい！文でしか述べられていないので、「だれ」＝「かばんちゃん」という割り当てのみがこの命題を真にします。</p>
<h3 id="条件つきのすごーい！文"><a href="#条件つきのすごーい！文" class="headerlink" title="条件つきのすごーい！文"></a>条件つきのすごーい！文</h3><p>条件つきのすごーい！文は、ある命題が真であるときに、別の命題が成り立つことを表明します。例えば、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ きみ が 自然数の フレンズ なら</span><br><span class="line">きみ の 次 も 自然数の フレンズ なんだね！</span><br></pre></td></tr></table></figure>
<p>は変数「きみ」に適当な割り当てがなされて命題「きみ が 自然数の フレンズ」が真だと判定されたなら、命題「きみ の 次 は 自然数の フレンズ」も真である、と述べています。ちなみに「～は」「～が」「～も」はすべて同じです。</p>
<p>式 <code>きみ の 次</code> は複合項というものです。Friends 言語では、式は「評価」されるものではなく、他の式とパターンマッチするためだけのものです。複合項の特徴は、単に「同一の形をした複合項とのみマッチする」ということです。すなわち、<code>きみ の 次</code> という式は、<code>? の 次</code> という形の式にだけマッチする式を表しています。</p>
<p>Friends 言語において <code>x の 次</code> という形の式は少しだけ特別で、自然数 <a href="ここでは0以上の整数のこと。">^natural_numbers</a> は「0 の 次 の 次 の … の 次」という複合項に解釈されます。すなわち、<code>0</code> はアトム ですが、<code>1</code> は <code>0 の 次</code>、<code>2</code> は <code>0 の 次 の 次</code> という項を表します。</p>
<p>例えば、次の質問をすると、</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ 0 は 自然数の フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が 自然数の フレンズ なら</span><br><span class="line">きみ の 次 も 自然数の フレンズ なんだね！</span><br><span class="line"></span><br><span class="line">3 は 自然数の フレンズ なんだっけ？</span><br></pre></td></tr></table></figure>
<p>3 は 0 ではありませんから、2つ目の条件つきのすごーい！文を使って真偽を判定することになります。<br>この命題が真であるには、<code>きみ の 次</code> = <code>3</code> = <code>0 の 次 の 次 の 次</code> でなければなりませんから、<strong>パターンマッチ</strong> により、<code>きみ</code> = <code>0 の 次 の 次</code> = 2 という割り当てが得られます。<br>加えて、条件「2 が 自然数の フレンズ」が成り立たなければなりませんが、これも同様の方法で推論できます。<br>したがって、「0 は 自然数の フレンズ」、だから「1 は 自然数の フレンズ」、なので「2 は 自然数の フレンズ」、ゆえに「3 は 自然数 のフレンズ」という推論ができます。</p>
<p>3の倍数、5の倍数、15の倍数の判定も同様に可能です。</p>
<h3 id="たーのしー！節"><a href="#たーのしー！節" class="headerlink" title="たーのしー！節"></a>たーのしー！節</h3><p>FizzBuzz フレンズの定義を再掲します。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ きみ が 15の倍数の フレンズ なら</span><br><span class="line">きみ と FizzBuzz は FizzBuzz フレンズ なんだね！ たーのしー！</span><br><span class="line">すごーい！ きみ が 3の倍数の フレンズ なら</span><br><span class="line">きみ と Fizz は FizzBuzz フレンズ なんだね！ たーのしー！</span><br><span class="line">すごーい！ きみ が 5の倍数の フレンズ なら</span><br><span class="line">きみ と Buzz は FizzBuzz フレンズ なんだね！ たーのしー！</span><br><span class="line">すごーい！ きみ が 自然数の フレンズ なら</span><br><span class="line">きみ と きみ は FizzBuzz フレンズ なんだね！</span><br></pre></td></tr></table></figure>
<p>n の FizzBuzz 表現 (Fizz/Buzz/FizzBuzz/n) を fizzbuzz(n) と書くことにします。FizzBuzz フレンズは、簡単にいえば、すべての自然数 n について命題「n と fizzbuzz(n) が FizzBuzz フレンズ」が真になるような述語です。</p>
<p>すごーい！文の末尾につく「たーのしー！」節は、その文が命題を真にすると、残りのすごーい！文を探索しない、という機能を持ちます。すなわち、命題「x と y が FizzBuzz フレンズ」の真偽を判定するとき、「x が 15の倍数の フレンズ」だと分かったら、残りの3つの文 (3の倍数なら、5の倍数なら、自然数なら、というやつ) は無視する、ということです。もしこれがないと、「15 と FizzBuzz が FizzBuzz フレンズ」であると同時に、「15 と Fizz も FizzBuzz フレンズ」でもあることになってしまいます。</p>
<h3 id="助詞"><a href="#助詞" class="headerlink" title="助詞"></a>助詞</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ 0 は きみ の 次 より 小さい フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が かのじょ より 小さい フレンズ なら</span><br><span class="line">きみ の 次 は かのじょ の 次 より 小さい フレンズ なんだね！</span><br></pre></td></tr></table></figure>
<p>「x は y より 小さい フレンズ」は「x と y が 小さい フレンズ」を表す糖衣構文です。<br>それ以外は前述の通りです。</p>
<h3 id="非決定性"><a href="#非決定性" class="headerlink" title="非決定性"></a>非決定性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">すごーい！ きみ が かのじょ より 小さい フレンズ なら</span><br><span class="line">きみ が きみ と かのじょ との 間の フレンズ なんだね！</span><br><span class="line">すごーい！ きみ が かのじょ より 小さい フレンズ で</span><br><span class="line">かれ が きみ の 次 と かのじょ との 間の フレンズ なら</span><br><span class="line">かれ も きみ と かのじょ との 間の フレンズ なんだね！</span><br></pre></td></tr></table></figure>
<p>「x で y」という命題は、x と y が両方真である、という命題 (論理積) を表します。</p>
<p>「間の」フレンズのおもしろいところは、それを真にする割り当てが複数あることです。というのも、命題「あなた が 0 と 3 との 間の フレンズ」を真にする割り当ては、<code>あなた</code> = 0, 1, 2 の3つあります。このように解が一意に定まらないことを、推論の <strong>非決定性</strong> といいます。</p>
<p>推論を追ってみましょう。命題「0 が 3 より 小さい フレンズ」は、「小さい」の定義により成り立つと分かります (詳細は割愛)。命題「あなた が 0 と 3 との 間の フレンズ」が真になるには、まず1つ目のすごーい！文により、結論「あなた が あなた と 3 との 間の フレンズ」とマッチする場合が考えられます。パターンマッチにより <code>あなた</code> = <code>0</code> という割り当てが得られます。</p>
<p>この文には「たーのしー！」節がないので、次のすごーい！文も適用できます。「あなた が 0 と 3 との 間の フレンズ」と「かれ も きみ と かのじょ との 間の フレンズ」を見比べて、「あなた = かれ」「0 = きみ」「3 = かのじょ」という割り当てを得ます。そして、条件「かれ が きみ の 次 と かのじょ との 間の フレンズ」＝「あなた が 0 の 次 と 3 との 間の フレンズ」が真であるかを判定します。再び1つ目のすごーい！文により、<code>あなた</code> = <code>0 の 次</code> = <code>1</code> という割り当てを得ます。これの繰り返しになります。</p>
<h2 id="Prolog"><a href="#Prolog" class="headerlink" title="Prolog"></a>Prolog</h2><p>実際のところ、Friends 言語は Prolog という「論理型プログラミング言語」の文法を変更したものです。興味があれば、Prolog について調べてみてください。Prolog の処理系には <a href="https://az-prolog.com/" target="_blank" rel="noopener">AZ-Prolog</a> や <a href="http://www.swi-prolog.org/" target="_blank" rel="noopener">SWI-Prolog</a> などがあります。</p>
<h2 id="動作環境"><a href="#動作環境" class="headerlink" title="動作環境"></a>動作環境</h2><p>(追記 3/7) Friends 言語を Mac や Linux でも動くようにしてもらえました。</p>
<p><a href="http://leko.jp/archives/933" target="_blank" rel="noopener">すごーい！きみはフレンズ言語をDockerizeできるフレンズなんだね！</a></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><ul>
<li><a href="http://kemono-friends.jp/" target="_blank" rel="noopener">けものフレンズプロジェクト｜公式サイト</a></li>
<li><a href="http://qiita.com/ShunIchikawa/items/6449f492dc38a7201162" target="_blank" rel="noopener">Prolog実践入門 - AIに特化した老舗言語</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2017-02-12/friends-lang/" data-id="cjnspsyyf002ekfcxqu60zmm4" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Prolog/">Prolog</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/ネタ/">ネタ</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/プログラミング言語/">プログラミング言語</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/言語実装/">言語実装</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-reports-with-wpf" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016-12-25/reports-with-wpf/" class="article-date">
  <time datetime="2016-12-24T15:00:00.000Z" itemprop="datePublished">2016-12-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016-12-25/reports-with-wpf/">WPF/XAMLで帳票のデザイン・印刷を行う</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://qiita.com/vain0x/items/0ec44dc198433675ea2f" target="_blank" rel="noopener">Qiita</a></p>
<p>※これは <a href="http://qiita.com/advent-calendar/2016/xaml" target="_blank" rel="noopener">XAML Advent Calendar 2016</a> の25日目の記事です。</p>
<p>WPF/XAML を使って帳票のデザインから印刷までやってみたという話です。ソースコードが GitHub にありますので、それと同様にやればできます。</p>
<p><a href="https://github.com/vain0x/VainZero.WpfReportPrinting" target="_blank" rel="noopener">vain0x/VainZero.WpfReportPrinting: WPFで帳票を作成するサンプル</a></p>
<h2 id="要約"><a href="#要約" class="headerlink" title="要約"></a>要約</h2><ul>
<li>XAML というマークアップ言語で帳票のデザインから印刷までできれば、たくさんの利点がある。</li>
<li>WPF アプリケーションで帳票のプレビューや印刷を行うサンプルを作った。</li>
<li>ページネーションが大変だったけどなんとかなった。</li>
</ul>
<h2 id="前提知識"><a href="#前提知識" class="headerlink" title="前提知識"></a>前提知識</h2><p>XAML、WPF について簡単に説明します。</p>
<p>XAML とは、GUIアプリケーションの外観を記述するマークアップ言語です。WEB 系の人には「HTML+CSS みたいなもの」といえばイメージしやすいのではないでしょうか。</p>
<p>WPF とは、XAML と .NET 言語 (C# など) を用いて、Windows PC 用のネイティヴ アプリケーションを作るためのフレームワークです。XAML は WPF 以外でも使いますが、筆者は WPF しかやったことがないので、ひとまず本稿のターゲットは WPF のみとします。</p>
<h2 id="利点"><a href="#利点" class="headerlink" title="利点"></a>利点</h2><p>WPF/XAML で帳票を作ることにはいくつかの利点があります。</p>
<ul>
<li><strong>無料</strong><ul>
<li>WPFは Visual Studio (無料) をインストールすれば無料で使えます。商用利用する場合は、Visual Studio の有償ライセンスを購入することで、やはりWPFは無料で使えます。</li>
</ul>
</li>
<li><strong>学習コストの削減</strong><ul>
<li>本稿と先述のソースコードをご覧いただければ、みなさんはWPFの知識だけで帳票のデザインから印刷まで行えるようになります。すなわち、帳票フレームワークに習熟するコストを省略できるわけです。</li>
<li>特に、帳票フレームワーク固有のデザイナーではなく、Visual Studio の高機能なXAMLデザイナーを利用して、プレビューを見ながらデザインを行える、というのも大きな利点です。これについては、参考リンクのブログ記事が詳しいです。</li>
</ul>
</li>
<li><strong>プレビューの容易さ</strong><ul>
<li>詳しくは後述しますが、帳票をXAMLで作ることで、プレビューはほぼ完璧にできます。プレビュー機能もWPFで簡単に実装でき、メインのアプリケーションとシームレスに繋がります。</li>
</ul>
</li>
<li><strong>ビューモデルの流用</strong><ul>
<li>帳票として印刷するデータ (GUIオブジェクト) の背景となるデータ構造として、WPFアプリケーションにあるものをそのまま使えることがあります。例えば、ユーザーが画面上の入力フォームにデータを記入し、それと等価な帳票を印刷する、といった場合です。</li>
</ul>
</li>
<li><strong>XAML本来の利点</strong>――拡張性、可変レイアウト、など<ul>
<li>XAMLの売りとして、あらゆる要素の外観を完全にカスタマイズできる、というのがあります。これは帳票の用途にも役立つでしょう。実際、今回のサンプルでもスタイル機能をふんだんに活用しています。</li>
<li>ウィンドウサイズを意識することなくウィンドウをデザインできるのと同様に、用紙サイズを意識することなく帳票を作れます。</li>
</ul>
</li>
</ul>
<h2 id="簡単な帳票"><a href="#簡単な帳票" class="headerlink" title="簡単な帳票"></a>簡単な帳票</h2><p>まずは簡単な帳票を例に挙げて、印刷する方法まで一通り解説します。簡単な帳票とは、タイトルがどーんとあって、日付が右寄せで、あとは本文という感じです。まずはプレビュー画面のスクリーンショットをご覧ください。</p>
<img src="/blog/2016-12-25/reports-with-wpf/hello-world-report.png" title="簡単な帳票のプレビュー画面">
<p>ビューモデルと XAML は次のようになっています。UI要素はプレビュー用と印刷用の2つ (以上) をインスタンス化する必要があるので、 DataTemplate の形で定義しています。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 印刷するページに対応するビューモデル。</span></span><br><span class="line"><span class="comment">// データをXAML側に埋め込んでしまったので中身がない。</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">HelloWorldPageViewModel</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    上記のビューモデルの表示方法を定義するテンプレート。</span></span><br><span class="line"><span class="comment">    Window.Resources プロパティの下に配置する。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DataTemplate</span> <span class="attr">DataType</span>=<span class="string">"&#123;x:Type local:HelloWorldPageViewModel&#125;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Grid</span> <span class="attr">Margin</span>=<span class="string">"30"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Center"</span> <span class="attr">FontSize</span>=<span class="string">"30"</span> <span class="attr">Text</span>=<span class="string">"ハローワールド"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">HorizontalAlignment</span>=<span class="string">"Right"</span> <span class="attr">Text</span>=<span class="string">"2007/08/31"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">TextBlock</span> <span class="attr">Text</span>=<span class="string">"Hello, world!"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">StackPanel</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Grid</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">DataTemplate</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="プレビュー"><a href="#プレビュー" class="headerlink" title="プレビュー"></a>プレビュー</h3><p>帳票のデザインが終わったので、次はプレビューです。</p>
<p>プレビューは、簡単にいえば、上に書いた XAML を「紙っぽいパネル」に載せるだけです。紙っぽさの演出についてはソースコードを参照してください。</p>
<p>ここで重要なのは紙のサイズ (A4 とか) です。というのも、ページネーションや文章の折り返しなどが用紙サイズに依存してしまうため、プレビュー時点で用紙サイズを決定しておくのが無難です。(もちろんプレビューをしないというのも1つの手です。)</p>
<p>用紙サイズ (mm 単位) から要素のサイズを換算するには、dpi を知る必要がありますが、ここで嬉しいお知らせがあります。後述するように、印刷時にはUI要素を FixedDocument というクラスの子孫要素に配置するのですが、FixedDocument の中身は 96dpi で固定されます。すなわち、FixedDocument の中身 (印刷するデータ) を 96dpi 決め打ちで作成しておけば、その FixedDocument を 600dpi のレーザープリンターに送信しても、同じ見栄えのものが印刷されるようになっています。 (参考: <a href="https://msdn.microsoft.com/ja-jp/library/ms748388%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">WPF のドキュメント</a>)</p>
<p>要するに、印刷するデータは 96dpi で作ればよいわけです。</p>
<p>例えば A4 (縦) は、ISO 規格で 210mm×297mm と決まっており、1 inch = 25.40 mm 、1 inch = 96 pixel で換算すれば 793.70×1122.52 となります。このサイズで作った紙っぽいパネルにページの中身を配置すれば、実際に印刷されるのと同じ見栄えのプレビューを表示できます。</p>
<p>次は印刷です。</p>
<h3 id="プリンターの選択"><a href="#プリンターの選択" class="headerlink" title="プリンターの選択"></a>プリンターの選択</h3><p>どのプリンターで印刷するかは、ユーザーに選択させる方法と、プログラム側で指定する方法の2通りがあります。</p>
<p>ユーザーに選択させる場合は、 <code>System.Windows.Controls</code> 名前空間の <code>PrintDialog</code> クラスを使います。(参考: <a href="https://msdn.microsoft.com/ja-jp/library/system.windows.controls.printdialog%28v=vs.110%29.aspx?f=255&amp;MSPPError=-2147217396" target="_blank" rel="noopener">PrintDialog クラス (System.Windows.Controls)</a>)</p>
<p>なお、プレビュー画面で選択された用紙サイズを印刷ダイアログの初期設定値にする方法は <del>時間が足りず調べられていません</del> 読者の演習課題とします。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows.Controls;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> printDialog = <span class="keyword">new</span> PrintDialog();</span><br><span class="line">    <span class="keyword">var</span> result = printDialog.ShowDialog();</span><br><span class="line">    <span class="keyword">if</span> (!result.HasValue || !result.Value)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 印刷ダイアログがキャンセルされた。</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 後の工程で使用する。</span></span><br><span class="line">    <span class="keyword">var</span> queue = printDialog.PrintQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>プログラム側で指定する場合は、プリントサーバーというのを使用するようです。詳しくは読者の演習課題とします。</p>
<p>ここでは、コンピューター自身を表すサーバー (localhost みたいなもの) である <code>LocalPrintServer</code> から、デフォルトのプリンターを指定する方法をとります。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System.Printing を参照に追加する必要があります。</span></span><br><span class="line"><span class="keyword">using</span> System.Printing;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Print</span>(<span class="params">Size pageSize</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> printServer = <span class="keyword">new</span> LocalPrintServer();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 既定のプリンターを表す PrintQueue を取得する。</span></span><br><span class="line">    <span class="keyword">var</span> queue = printServer.DefaultPrintQueue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// プレビュー画面で用紙サイズを選択させる場合は、用紙サイズを設定しておく。</span></span><br><span class="line">    <span class="keyword">var</span> ticket = queue.PrintTicket;</span><br><span class="line">    ticket.PageMediaSize = <span class="keyword">new</span> PageMediaSize(pageSize.Width, pageSize.Height);;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="FixedDocument-の生成"><a href="#FixedDocument-の生成" class="headerlink" title="FixedDocument の生成"></a>FixedDocument の生成</h3><p>先述の通り、印刷するデータを持つ FixedDocument のインスタンスを用意します。この作業は再利用可能な形式にしてあります。</p>
<p>まず「印刷するデータを複数のページに分割する」機能 (ページネーション) を提供するインターフェイスを定義しておきます。<code>IPaginatable</code> と呼びましょう。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Windows;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">IPaginatable</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> ページのサイズを受け取って、オブジェクトのリストを返す。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> リストに含まれる各オブジェクトは、それぞれ1つのページの中身を表す。</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function">IReadOnlyList&lt;<span class="keyword">object</span>&gt; <span class="title">Paginate</span>(<span class="params">Size pageSize</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>いま例にとっているハローワールド帳票では、常に1つのページになりますので、Paginate メソッドは1つのオブジェクトを返せばよいわけです。次のようになります。 [^ireport]</p>
<p>[^ireport]: GitHub においてあるソースコードでは、HelloWorldReport は IPaginatable だけでなく、IPaginatable を拡張する IReport というインターフェイスを実装していますが、それはサンプルの都合です。あまり気にしなくてかまいません。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">HelloWorldReport</span></span><br><span class="line">    : <span class="title">IPaginatable</span></span><br><span class="line">&#123;</span><br><span class="line">    IReadOnlyList&lt;<span class="keyword">object</span>&gt; Pages &#123; <span class="keyword">get</span>; &#125; =</span><br><span class="line">        <span class="keyword">new</span> <span class="keyword">object</span>[]</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">new</span> HelloWorldPageViewModel(),</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IReadOnlyList&lt;<span class="keyword">object</span>&gt; <span class="title">Paginate</span>(<span class="params">Size size</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> Pages;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>あとは次の拡張メソッドを呼ぶだけです。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">PaginatableExtension</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FixedDocument</span><br><span class="line">        ToFixedDocument(<span class="keyword">this</span> IPaginatable paginatable, Size pageSize)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> document = <span class="keyword">new</span> FixedDocument();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">foreach</span> (<span class="keyword">var</span> content <span class="keyword">in</span> paginatable.Paginate(pageSize))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> presenter =</span><br><span class="line">                <span class="keyword">new</span> ContentPresenter()</span><br><span class="line">                &#123;</span><br><span class="line">                    Content = content,</span><br><span class="line">                    Width = pageSize.Width,</span><br><span class="line">                    Height = pageSize.Height,</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> page =</span><br><span class="line">                <span class="keyword">new</span> FixedPage()</span><br><span class="line">                &#123;</span><br><span class="line">                    Width = pageSize.Width,</span><br><span class="line">                    Height = pageSize.Height,</span><br><span class="line">                &#125;;</span><br><span class="line">            page.Children.Add(presenter);</span><br><span class="line"></span><br><span class="line">            page.Measure(pageSize);</span><br><span class="line">            page.Arrange(<span class="keyword">new</span> Rect(<span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>), pageSize));</span><br><span class="line">            page.UpdateLayout();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> pageContent = <span class="keyword">new</span> PageContent() &#123; Child = page &#125;;</span><br><span class="line">            document.Pages.Add(pageContent);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> document;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>このメソッドは、Paginate メソッドが返したリストの各要素につき、それを固定サイズの ContentPresenter に入れて、それを FixedPage に入れて、それを PageContent に入れて、それを FixedDocument に入れる、という感じです。</p>
<p>こうして FixedDocument を手に入れました。</p>
<h3 id="プリンターへの送信"><a href="#プリンターへの送信" class="headerlink" title="プリンターへの送信"></a>プリンターへの送信</h3><p>最後に、この FixedDocument を、選択されたプリンターに送信すれば完了です。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// System.Printing の参照を追加する必要があります。</span></span><br><span class="line"><span class="keyword">using</span> System.Printing;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">var</span> writer = PrintQueue.CreateXpsDocumentWriter(queue);</span><br><span class="line">    writer.Write(document);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>できました。</p>
<h2 id="複雑な帳票"><a href="#複雑な帳票" class="headerlink" title="複雑な帳票"></a>複雑な帳票</h2><p>次に複数ページの帳票、すなわちページネーションの方法を解説します。</p>
<p>まずはプレビュー画面のスクリーンショットをごらんください。</p>
<img src="/blog/2016-12-25/reports-with-wpf/paginated-report.png" title="ページネーションを含む帳票のスクリーンショット">
<p>XAML は結構な分量なので省略します。表の部分には、 <del>スタイルをガチガチに決めた DataGrid</del> <strong>HeaderedGrid という DataGrid のようなもの</strong> [^DataGrid_issue]を使用しています。</p>
<p>[^DataGrid_issue]: 一部のプリンターでは、DataGrid や ListView のレイアウトが乱れてしまう、という問題があるようです。これについては調査中です。DataGrid を使用していたころのバージョンは、タグ <a href="https://github.com/vain0x/VainZero.WpfReportPrinting/tree/v1.2.0" target="_blank" rel="noopener">v1.2.0</a> にあります。</p>
<p>簡単な帳票との差は、Paginate メソッドの実装だけです。</p>
<h3 id="Paginate"><a href="#Paginate" class="headerlink" title="Paginate"></a>Paginate</h3><p>ここでは実際にUI要素をインスタンス化することでページネーションを行います。(というか、それ以外にうまい方法があるのでしょうか。)</p>
<p>おおまかな手順は次の通りです。</p>
<ol start="0">
<li>すべての行のデータを持った帳票を生成する。</li>
<li>帳票の中にある ScrollViewer を見つける。<ul>
<li>Visual Tree を辿ればよい。詳しくは参考リンクにあるブログ記事を参照。</li>
</ul>
</li>
<li>「スクロールなしで見えている行の数」を数える。<ul>
<li>ScrollViewer.ViewportHeight が「スクロールなしで見える範囲の実際の高さ (ピクセル単位)」になっているので、各行の高さ (ActualHeight) の和がそれを超えない範囲を調べる。</li>
</ul>
</li>
<li>それらの行からなる帳票を生成する。これを1ページとする。</li>
<li>前のページに含まれる行を非表示にする。</li>
<li>次のページに表示すべき行だけが表示された状態になるので、繰り返し。</li>
</ol>
<p>実際のソースコードはやや長いので、最初に張ったリンクから見てもらえればと思います。帳票の定義は Demo プロジェクトの <a href="https://github.com/vain0x/VainZero.WpfReportPrinting/blob/v1.3.0/VainZero.WpfReportPrinting.Demo/Reports/OrderForm.cs" target="_blank" rel="noopener">Reports/OrderForm.cs</a> の中にあります。ページネーションは、 Core プロジェクトの <a href="https://github.com/vain0x/VainZero.WpfReportPrinting/blob/v1.3.0/VainZero.WpfReportPrinting.Core/Windows/Documents/ISingleHeaderedGridPage.cs" target="_blank" rel="noopener">Windows/Documents/ISingleHeaderedGridPage.cs</a> にあります。</p>
<h2 id="サンプルプログラムの概略"><a href="#サンプルプログラムの概略" class="headerlink" title="サンプルプログラムの概略"></a>サンプルプログラムの概略</h2><p>必殺「ソースコードをごらんください」を思ったより使ってしまったので、サンプルプログラムの概略について説明します。</p>
<p>念のためリンクを再掲します:<br><a href="https://github.com/vain0x/VainZero.WpfReportPrinting" target="_blank" rel="noopener">vain0x/VainZero.WpfReportPrinting: WPFで帳票を作成するサンプル</a></p>
<h3 id="ソリューション構成"><a href="#ソリューション構成" class="headerlink" title="ソリューション構成"></a>ソリューション構成</h3><p>ソリューションは <code>VainZero.WpfReportPrinting.Core</code> と <code>VainZero.WpfReportPrinting.Demo</code> の2つのプロジェクトからなります。</p>
<p>前者 (<code>.Core</code>) は再利用可能な部品で、そのまま流用できるようになっています。中身は、先述の <code>IPaginatable</code> とその拡張メソッド、および VisualTree がらみの小さな拡張メソッドです。</p>
<p>後者 (<code>.Demo</code>) は、帳票のプレビューと印刷の機能を持つアプリケーションです。印刷時のオプションは多数ありますので、これをベースにして、必要によりカスタマイズしながら作るのがよいと思います。</p>
<h3 id="使い方"><a href="#使い方" class="headerlink" title="使い方"></a>使い方</h3><p>まず使い方から説明します。</p>
<p><code>.Demo</code> アプリを実行すると、ウィンドウが1つ表示されます。まずは左側のペインにあるリストボックスで、プレビューする帳票の種類を選びます。種類というのは、本稿で挙げた「簡単な帳票」(ハローワールド)と「複雑な帳票」(注文書)の2つです。</p>
<p>右側ペインの上部には、コンボボックスと印刷ボタンがあります。左端のコンボボックスでは、紙のサイズを指定します。紙のサイズが変わるたびにページネーションが再計算されるのがミソです。</p>
<p>右側ペインの残りの部分はプレビューです。</p>
<p>印刷ボタンを押すと、デフォルトのプリンターで印刷されます。(印刷ダイアログは表示されません。)</p>
<h3 id="実装"><a href="#実装" class="headerlink" title="実装"></a>実装</h3><p>メインウィンドウ (MainWindow.xaml) の中身は、1つの <code>SampleReportPreviewer</code> クラス (を DataTemplate で表示したもの) であり、これは先述の通り「左側ペイン」(帳票セレクター/<code>Reports.ReportSelector</code>)と「右側ペイン」(プレビューアー/<code>Previewing.Previewer</code>)からなります。</p>
<p><code>ReportSelector</code> は本当にただの <code>ListBox</code> ですが、2つ注意するところがあります。</p>
<p>1点は、<a href="https://github.com/runceel/ReactiveProperty" target="_blank" rel="noopener">ReactiveProperty</a> というクラスです。これは平たくいえば次のようなクラスです (※実際の定義ではありません)。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public class ReactiveProperty&lt;T&gt;</span><br><span class="line">    : INotifyPropertyChanged</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">event</span> PropertyChangedEventHandler PropertyChanged;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> T _value;</span><br><span class="line">    <span class="keyword">public</span> T Value</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _value; &#125;</span><br><span class="line">        <span class="keyword">set</span></span><br><span class="line">        &#123;</span><br><span class="line">            _value = <span class="keyword">value</span>;</span><br><span class="line">            PropertyChanged?.Invoke(<span class="keyword">this</span>, <span class="keyword">new</span> PropertyChangedEventArgs(<span class="keyword">nameof</span>(Value)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>値をこれでラップしておくことで、 <code>INotifyPropertyChanged</code> の実装をいちいち手書きする (あるいは継承する) 必要がなくなる、という寸法ですね。</p>
<p>もう1点は、リストボックスの各要素の型である <code>IReport</code> です。注釈にも書きましたが、これは <code>IPaginatable</code> に1つのプロパティを加えただけのインターフェイスです。そのプロパティ (<code>ReportName</code>) というのは、単にリストボックスの各項目に表示するための名前(文字列)です。そのため、<code>IPaginatable</code> と同じだと思ってかまいません。</p>
<p>さて、プレビューアーにあるコンボボックスも同様のことに気をつければ問題ないはずです。</p>
<p><code>Previewer</code> のコンストラクターにある <a href="https://github.com/vain0x/VainZero.WpfReportPrinting/blob/v1.1.0/VainZero.WpfReportPrinting.Demo/Previewing/Previewer.cs#L42" target="_blank" rel="noopener">この式</a> は、Rx を知らないと読み解けないかもしれません。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Pages =</span><br><span class="line">    Report.CombineLatest(</span><br><span class="line">        MediaSizeSelector.SelectedSize,</span><br><span class="line">        (r, pageSize) =&gt; r.Paginate(pageSize)</span><br><span class="line">    )</span><br><span class="line">    .ToReadOnlyReactiveProperty();</span><br></pre></td></tr></table></figure>
<p>これは平たくいえば「<code>Report</code>, <code>MediaSizeSelector.SelectedSize</code> の最新の値を <code>r</code>, <code>pageSize</code> とするとき、 <code>r.Paginate(pageSize)</code> の結果を <code>Pages</code> の値とする」という意味です。もう少し手続き的にいえば、まず <code>Report</code> と <code></code>MediaSizeSelector.SelectedSize<code>の値をとってきて、</code>Paginate` します。加えて、そのどちらかのプロパティが変更されるたび (リストボックスやコンボボックスの選択要素が変わるたび)、ページネーションを再試行します。</p>
<p>最後に印刷ボタンですが、これは押されたとき、<code>Previewer.PrintCommand</code>→<code>Previewer.Print</code> を経由して <code>Printer.Print</code> まで行き、そこからは前半で述べた感じです。FixedDocument を作って、デフォルトのプリンターを取得して、ページサイズを指定して、印刷。</p>
<h2 id="おわりに"><a href="#おわりに" class="headerlink" title="おわりに"></a>おわりに</h2><p>いかがでしたでしょうか。不明点などあればコメントないし <a href="https://github.com/vain0x/VainZero.WpfReportPrinting/issues" target="_blank" rel="noopener">イシュー</a> をお願いします。</p>
<h2 id="参考リンク"><a href="#参考リンク" class="headerlink" title="参考リンク"></a>参考リンク</h2><h3 id="帳票関連"><a href="#帳票関連" class="headerlink" title="帳票関連"></a>帳票関連</h3><ul>
<li><a href="http://koty.hatenablog.com/entry/2013/12/15/122352" target="_blank" rel="noopener">WPFを帳票フレームワークとして使う - @kotyのブログ</a></li>
</ul>
<h3 id="WPF関連"><a href="#WPF関連" class="headerlink" title="WPF関連"></a>WPF関連</h3><ul>
<li><a href="http://stackoverflow.com/a/7601504/6419575" target="_blank" rel="noopener">c# - Check visible rows in a WPF DataGrid - Stack Overflow</a></li>
<li><a href="http://blog.xin9le.net/entry/2013/10/29/222336" target="_blank" rel="noopener">VisualTreeの子孫要素を取得する - xin9le.net</a></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2016-12-25/reports-with-wpf/" data-id="cjnsq05u80004lccx4lm4mpke" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/WPF/">WPF</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/印刷/">印刷</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-lists-with-no-alloc-enumerator" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016-12-21/lists-with-no-alloc-enumerator/" class="article-date">
  <time datetime="2016-12-20T15:00:00.000Z" itemprop="datePublished">2016-12-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016-12-21/lists-with-no-alloc-enumerator/">IReadOnlyListの列挙時にヒープ領域の使用を避ける</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://qiita.com/vain0x/items/8f89843325ab303c6e04" target="_blank" rel="noopener">Qiita</a></p>
<p>IReadOnlyListの列挙時にヒープ領域の使用を避ける方法を紹介します。</p>
<h2 id="前提知識"><a href="#前提知識" class="headerlink" title="前提知識"></a>前提知識</h2><h3 id="値型のボックス化"><a href="#値型のボックス化" class="headerlink" title="値型のボックス化"></a>値型のボックス化</h3><p>値型とは何か、ボックス化とは何か、は以下の記事を参照。</p>
<ul>
<li><a href="http://ufcpp.net/study/csharp/oo_reference.html" target="_blank" rel="noopener">値型と参照型 - C# によるプログラミング入門 | ++C++; // 未確認飛行 C</a></li>
<li><a href="http://ufcpp.net/study/csharp/RmBoxing.html" target="_blank" rel="noopener">ボックス化 - C# によるプログラミング入門 | ++C++; // 未確認飛行 C</a></li>
</ul>
<p>系として次のことがいえます。</p>
<ul>
<li>値型をインターフェイス型にキャストすると、ボックス化が起こります。</li>
<li><del>型変数 <code>T</code> に <code>struct</code> 制約がついていないとき、値型の値を型 <code>T</code> にキャストすると、ボックス化が起こります。</del> (追記: 起こりません。)</li>
</ul>
<h3 id="foreach-文のダックタイピング"><a href="#foreach-文のダックタイピング" class="headerlink" title="foreach 文のダックタイピング"></a>foreach 文のダックタイピング</h3><p>foreach 文は、渡された列挙対象のコレクションが <code>GetEnumerator</code> という名前のメソッドを public に公開していたら、それを使って列挙を行います [^foreach_duck_typing] 。<code>GetEnumerator</code> の返値型が <code>IEnumerator&lt;_&gt;</code> である必要はなく、返値が <code>IEnumerator&lt;_&gt;</code> にキャストされることもありません。</p>
<p>[^foreach_duck_typing]: ちなみにコレクションが <code>IEnumerable</code> や <code>IEnumerable&lt;_&gt;</code> を実装している必要はありません。また、 <code>GetEnumerator</code> が返すインスタンスが <code>IEnumerator</code> や <code>IEnumerator&lt;_&gt;</code> を実装している必要もありません。</p>
<h2 id="ストーリー"><a href="#ストーリー" class="headerlink" title="ストーリー"></a>ストーリー</h2><h3 id="ヒープ確保を避けたい"><a href="#ヒープ確保を避けたい" class="headerlink" title="ヒープ確保を避けたい"></a>ヒープ確保を避けたい</h3><p><code>IEnumerable&lt;T&gt;.GetEnumerator()</code> の返値型は <code>IEnumerator&lt;T&gt;</code> なので、新しいオブジェクトを生成して返そうと思うと、ヒープ確保を避けられません。(値型を返そうとすると、ボックス化されてしまう。)</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">F</span>(<span class="params">IEnumerable&lt;<span class="keyword">int</span>&gt; xs</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// xs.GetEnumerator() が実行される。</span></span><br><span class="line">    <span class="keyword">foreach</span> (<span class="keyword">var</span> x <span class="keyword">in</span> xs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>いま、型が <code>IEnumerable&lt;T&gt;</code> ではなく <code>IReadOnlyList&lt;T&gt;</code> だとすると、ヒープ確保を回避しつつ列挙を行えます。配列と同じように、インデックスで順次アクセスしていけばいいわけです。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">G</span>(<span class="params">IReadOnlyList&lt;<span class="keyword">int</span>&gt; xs</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ボックス化は起こらない。</span></span><br><span class="line">    <span class="keyword">var</span> count = xs.Count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">var</span> x = xs[i];</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="実装の重複を避けたい"><a href="#実装の重複を避けたい" class="headerlink" title="実装の重複を避けたい"></a>実装の重複を避けたい</h3><p>よりよいパフォーマンスを求めるために、シーケンスの走査を行うメソッドに IReadOnlyList 版と IEnumerable 版の2つを用意することにしたとします。問題となるのは、2つのオーバーロードをどのように実装するかです。</p>
<h3 id="ラッパーで解決"><a href="#ラッパーで解決" class="headerlink" title="ラッパーで解決"></a>ラッパーで解決</h3><p>上記の2つのコードの違いは列挙方法の違いだけなので、列挙子を使って抽象化できます。</p>
<p>列挙子の実装例はここにあります: <a href="https://github.com/DotNetKit/DotNetKit.StructEnumerator/blob/v0.1.1/DotNetKit.StructEnumerator/Collections/StructEnumerator.cs" target="_blank" rel="noopener">StructEnumerator.cs</a></p>
<p>実際に使ってみましょう。例として、First メソッドと同じものを作ってみます。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> <span class="title">MyLinq</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">static</span> X MyFirstCore&lt;X, TEnumerator&gt;(TEnumerator enumerator)</span><br><span class="line">        <span class="keyword">where</span> TEnumerator : <span class="keyword">struct</span>, IEnumerator&lt;X&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">using</span> (enumerator)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (enumerator.MoveNext())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> enumerator.Current;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidOperationException();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IReadOnlyList を受け取るオーバーロード</span></span><br><span class="line">    <span class="comment">// 列挙子がボックス化されない。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> X MyFirst&lt;X&gt;(IReadOnlyList&lt;X&gt; list)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MyFirstCore&lt;X, ReadOnlyListEnumerator&lt;X&gt;&gt;(<span class="keyword">new</span> ReadOnlyListEnumerator&lt;X&gt;(list));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IEnumerable を受け取るオーバーロード</span></span><br><span class="line">    <span class="comment">// ヒープを使うけれど、実装の共通化はできている。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> X MyFirst&lt;X&gt;(IEnumerable&lt;X&gt; enumerable)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> MyFirstCore&lt;X, StructEnumerator&lt;X&gt;&gt;(<span class="keyword">new</span> StructEnumerator&lt;X&gt;(enumerable.GetEnumerator()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>列挙時にヒープ確保が行われないことを確認するには、次のように <code>GC.GetTotalMemory</code> を使います。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> xs = Enumerable.Range(<span class="number">0</span>, <span class="number">100</span>).ToArray();</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0L</span>;</span><br><span class="line">        MyLinq.MyFirst(xs); <span class="comment">// おまじない</span></span><br><span class="line"></span><br><span class="line">        GC.Collect();</span><br><span class="line">        <span class="keyword">var</span> before = GC.GetTotalMemory(<span class="literal">false</span>);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                sum += MyLinq.MyFirst(xs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> after = GC.GetTotalMemory(<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">var</span> difference = after - before;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// difference == 0</span></span><br><span class="line"></span><br><span class="line">        Console.WriteLine(<span class="string">"Memory addition: &#123;0&#125;"</span>, difference);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="余談-List-lt-T-gt-は構造体列挙子を提供している"><a href="#余談-List-lt-T-gt-は構造体列挙子を提供している" class="headerlink" title="余談: List&lt;T&gt; は構造体列挙子を提供している"></a>余談: <code>List&lt;T&gt;</code> は構造体列挙子を提供している</h2><p><code>List&lt;T&gt;</code> は <code>IEnumerable&lt;T&gt;</code> を明示的に実装しつつ、<code>List&lt;T&gt;.Enumerator</code> という構造体を返す <code>GetEnumerator</code> メソッドを提供しています。<code>List&lt;T&gt;</code> 型の変数を <code>foreach</code> で回すときには、こちらが使用されるので、列挙子はボックス化されません。</p>
<p>参考: <a href="https://msdn.microsoft.com/ja-jp/library/b0yss765(v=vs.110" target="_blank" rel="noopener">List<t>.GetEnumerator メソッド</t></a>.aspx)</p>
<h2 id="余談-実行時型をみてリストか否か判断する-追記"><a href="#余談-実行時型をみてリストか否か判断する-追記" class="headerlink" title="余談: 実行時型をみてリストか否か判断する (追記)"></a>余談: 実行時型をみてリストか否か判断する (追記)</h2><p>標準ライブラリーの <code>IEnumerable&lt;_&gt;.First</code> メソッドに配列などのリストを渡しても、列挙子のボックス化によるヒープ確保は起こりません。というのも、メソッドが受け取る型こそ <code>IEnumerable&lt;_&gt;</code> ですが、その実行時型がリスト (<code>IList&lt;_&gt;</code>) であるかどうかをメソッドの内部で動的に判定していて、もしそうだったらインデックスでアクセスする (<code>list[0]</code> を返す) ようになっているためです。他のメソッドも同様です。</p>
<p>参考: <a href="https://referencesource.microsoft.com/#System.Core/System/Linq/Enumerable.cs,921" target="_blank" rel="noopener">First の実装</a></p>
<p>そういう意味で、本稿の <code>MyFirst</code> は若干ながら手抜きになってしまっています。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2016-12-21/lists-with-no-alloc-enumerator/" data-id="cjnspsyxi000hkfcx6yzoa23z" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C#</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-why-git-edit" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016-12-07/why-git-edit/" class="article-date">
  <time datetime="2016-12-06T15:00:00.000Z" itemprop="datePublished">2016-12-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016-12-07/why-git-edit/">GitEditを使うべき十の理由</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://qiita.com/vain0x/items/a97df4bd0f5f7de19d64" target="_blank" rel="noopener">Qiita</a></p>
<p><a href="https://github.com/vain0x/GitEdit" target="_blank" rel="noopener">GitEdit</a> とは、Git for Windows 用のエディターとして最適化されたテキストエディターです。</p>
<h2 id="要約"><a href="#要約" class="headerlink" title="要約"></a>要約</h2><ul>
<li>vi を覚えるのはめんどくさい。</li>
<li>Git 用のテキストエディターとして使うための条件が意外と多い。</li>
<li>結局、ふさわしいエディターが見つからなかったので自作した。</li>
<li>ぜひ<a href="https://github.com/vain0x/GitEdit/releases/latest" target="_blank" rel="noopener">ダウンロード</a>して下さい。</li>
</ul>
<h2 id="十の理由"><a href="#十の理由" class="headerlink" title="十の理由"></a>十の理由</h2><h3 id="1-軽量"><a href="#1-軽量" class="headerlink" title="1. 軽量"></a>1. 軽量</h3><p>機能を必要最小限に絞っているため、とても起動が速いです。</p>
<h3 id="2-文字コード"><a href="#2-文字コード" class="headerlink" title="2. 文字コード"></a>2. 文字コード</h3><p>日本語話者として、コミットメッセージに日本語を混ぜたい場面は少なくないでしょう。コミットメッセージに日本語を含めるには、ファイルを utf-8 などの文字コードで保存する必要があります。</p>
<p>ここで問題なのは、コミットメッセージを書き込むファイルを開く段階では、そのファイルに日本語の (すなわち半角文字ではない) 文字が含まれていないことがよくあるため、エディターが文字コードを判断するのが難しいということです。例えば、私が長らく愛用していた TeraPad は、半角文字だけからなるファイルを標準の文字コード (shift_jis) で開いてしまいます。</p>
<p>git_edit はそのようなファイルを utf-8 (BOM なし) で開くようになっています。</p>
<h3 id="3-改行文字"><a href="#3-改行文字" class="headerlink" title="3. 改行文字"></a>3. 改行文字</h3><p><code>git add --patch</code> の <code>e</code> オプションなどを使って差分を編集するとき、Git から提示されるファイルは改行コードが LF になっていて、保存するときも LF でなければエラーになってしまいます。そのため、編集に使うテキストエディタは改行コードを正しく扱う (あるいはLFだけ扱う) 必要があります。git_edit のエディター部分である AvalonEdit は、そのあたりちゃんとできています。</p>
<h3 id="4-構文強調"><a href="#4-構文強調" class="headerlink" title="4. 構文強調"></a>4. 構文強調</h3><p><code>git commit</code> に <code>-v</code> オプションをつけると、コミットメッセージを保存するファイルにの後半に差分(diff)をつけてくれます。コミットの内容がコミットメッセージを考える材料として使いやすく提示されるわけです。この機能のサポートとして、git_edit はコミットメッセージの編集時に diff の構文強調を有効化します。</p>
<h3 id="5-「保存して終了」コマンド"><a href="#5-「保存して終了」コマンド" class="headerlink" title="5. 「保存して終了」コマンド"></a>5. 「保存して終了」コマンド</h3><p>コミットメッセージや <code>rebase -i</code> の todo リストなどは、テキストを保存してからエディターを閉じる必要があります。git_edit では、1回のキー入力 (<code>Ctrl+W</code>) で保存→閉じるという2アクションを行えるようになっています。</p>
<h3 id="6-「クリアして終了」コマンド"><a href="#6-「クリアして終了」コマンド" class="headerlink" title="6. 「クリアして終了」コマンド"></a>6. 「クリアして終了」コマンド</h3><p>コミットメッセージや <code>rebase -i</code> の todo リストなどは、ファイルの中身を空っぽにして保存することで処理を「キャンセル」することができます。git_edit にはそのためのコマンド <code>Ctrl+Shift+W</code> があります。</p>
<h3 id="7-入力補完"><a href="#7-入力補完" class="headerlink" title="7. 入力補完"></a>7. 入力補完</h3><p>Control + Space で入力補完が効きます。</p>
<h3 id="8-テキストエディターエンジン-AvalonEdit"><a href="#8-テキストエディターエンジン-AvalonEdit" class="headerlink" title="8. テキストエディターエンジン AvalonEdit"></a>8. テキストエディターエンジン AvalonEdit</h3><p>名前がかっこいい。</p>
<h3 id="9-まとめ"><a href="#9-まとめ" class="headerlink" title="9. まとめ"></a>9. まとめ</h3><p>Git 用のテキストエディターに要求した条件のまとめ:</p>
<ul>
<li>起動が速い。</li>
<li>保存と終了が速い。</li>
<li>OS標準の文字コードより utf-8 (BOMなし) を優先する。</li>
<li>改行文字が LF のファイルを LF のまま編集・保存できる。</li>
<li>diff の構文着色ができる。</li>
<li>入力補完ができる。</li>
</ul>
<h2 id="10-おわりに"><a href="#10-おわりに" class="headerlink" title="10. おわりに"></a>10. おわりに</h2><p>この文章は <a href="https://www.sublimetext.com/3" target="_blank" rel="noopener">Sublime Text 3</a> で書きました。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2016-12-07/why-git-edit/" data-id="cjnspsyxo000mkfcxnvq2nxlk" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Git/">Git</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/テキストエディタ/">テキストエディタ</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-null-object-patterns" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016-08-18/null-object-patterns/" class="article-date">
  <time datetime="2016-08-17T15:00:00.000Z" itemprop="datePublished">2016-08-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016-08-18/null-object-patterns/">Nullオブジェクトパターンの紹介と正体</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://qiita.com/vain0x/items/c8adb679a6c253e5261f" target="_blank" rel="noopener">Qiita</a></p>
<p>デザインパターン「Nullオブジェクト」について解説します。加えて、後半でNullオブジェクトパターンに関する私見を述べます。</p>
<h2 id="なぜ「Nullオブジェクト」が必要か"><a href="#なぜ「Nullオブジェクト」が必要か" class="headerlink" title="なぜ「Nullオブジェクト」が必要か"></a>なぜ「Nullオブジェクト」が必要か</h2><p>C や C# などのいくつかの言語に null という概念があります。<code>null</code> はしばしば「何もない」や「失敗」といった <strong>特殊な状態</strong> を表す値として、null でない値と混ぜて使われますが、<code>null</code> と非 null の差異は次のようなやっかいな状況の引き金となります。</p>
<p><code>null</code> と非 null の違いの一つに、備えるメソッドの種類があります [^null_diversity] 。例えばプログラミング言語 C# では、<code>null</code> のメソッドを呼ぼうとすると、例外が投げられます。</p>
<p>[^null_diversity]: null の性質は言語によって異なります。例えば null に対して任意のメソッドを呼べるような言語に対して、本記事の話は無意味です。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 何らかのクラス X</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// オーバーライド可能なメソッド</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ThrowNullReferenceException</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 型 X の変数 x を null にする。</span></span><br><span class="line">    X x = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// x (= null) のメソッドを呼ぶ。例外が投げられる。</span></span><br><span class="line">    x.SomeMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>そのため、プログラムの処理中にエラーが起きると困る場合、 <code>null</code> のメソッドを呼んでしまわないようにする必要があります。</p>
<p>このような事情から、「<code>null</code> でない場合だけ、メソッドを実行する」(<code>null</code> の場合は何もしない)ようにしたいことがしばしばあります。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotThrowNullReferenceException</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 型 X の変数 x を null にする。</span></span><br><span class="line">    X x = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// x が null でない場合だけ、メソッドを呼び出す。</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x.SomeMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>しかしメソッドを呼ぶ際にいちいち if 文を書いていると、 if 文が大量に発生してしまいます。コードが増えるだけならまだしも、if 文を書き忘れて、意図せぬ例外を投げてしまうおそれもあります。</p>
<p>このような状況を回避する方法の1つが、 <strong>Nullオブジェクト</strong> です。</p>
<h2 id="Nullオブジェクトの作りかた"><a href="#Nullオブジェクトの作りかた" class="headerlink" title="Nullオブジェクトの作りかた"></a>Nullオブジェクトの作りかた</h2><p>Null オブジェクトとは、次のように定義される、「<code>null</code> の代わりに使われるオブジェクト」のことです。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X を継承した新しいクラス</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NullX</span></span><br><span class="line">    : <span class="title">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 「何もしない」メソッドとしてオーバーライドする。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>そして、型 X の変数には、<code>null</code> の代わりにこの NullX クラスのインスタンスを代入するようにします。これにより、変数が <code>null</code> ではないと分かるので、条件分岐を行わずとも安全にメソッドを呼び出せるようになります。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">NotThrowNullReferenceException</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 型 X の変数 x を (null ではなく) NullX のインスタンスにする。</span></span><br><span class="line">    X x = <span class="keyword">new</span> NullX();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// x は null でないと分かっているので、安心してメソッドを呼べる。</span></span><br><span class="line">    x.SomeMethod();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>めでたし、めでたし。</p>
<h2 id="nullの発生源"><a href="#nullの発生源" class="headerlink" title="nullの発生源"></a>nullの発生源</h2><p>(ここからは私見になります。)</p>
<p>ところで、そもそもなぜ、型 X の変数 (仮に <code>x</code> と呼ぶ) に <code>null</code> が入ってしまったのでしょうか。先ほどのサンプルでは、話を単純にするために <code>x</code> を使用する直前に <code>X x = null;</code> と書いていましたが、実際にはこんなコードはありえません。<code>x == null</code> になるには理由があるはずです。</p>
<p>C# の場合、理由は2つ考えられます:</p>
<ul>
<li><code>x</code> は初期化されなかった。(C# では、初期化されていない <code>x</code> の値は <code>null</code> になります。)</li>
<li>誰かが <code>x</code> に <code>null</code> を代入した。あるいは、誰かが <code>x</code> の初期値として <code>null</code> を指定した。</li>
</ul>
<h3 id="前者の場合"><a href="#前者の場合" class="headerlink" title="前者の場合"></a>前者の場合</h3><p>前者の場合、「<code>x</code> が初期化されないまま使用されている」ことになります。</p>
<p>ここで確認する必要があるのは、「<code>x</code> が初期化されないまま使用されることがあると <strong>開発者が理解している</strong> かどうか」です。理解していないのなら、 <code>x == null</code> で条件分岐するのではなく、 <code>x</code> が必ず初期化されるようにコードを修正するべきです。なぜなら、「なぜ <code>x == null</code> になるのか分からないけれど、とりあえず <code>x == null</code> の場合は何もしないようにしておく」という考えは、<code>null</code> のメソッドを呼び出すことで起こるはずだった例外を「<a href="http://qiita.com/jkr_2255/items/c335566aeb748c61e931" target="_blank" rel="noopener">握りつぶす</a>」ことと等価だからです。</p>
<p>一方、理解しているのであれば、それは <code>x</code> の初期化時に <code>null</code> を設定しているのと同じことですので、後者の場合に含まれると考えてよいでしょう。</p>
<h3 id="後者の場合"><a href="#後者の場合" class="headerlink" title="後者の場合"></a>後者の場合</h3><p>後者の場合、<code>null</code> を設定した人は、どういう意図をもってそれをしたのでしょうか。言い換えると、<code>x == null</code> である場合に、コードがどう動くことを期待しているのでしょうか。</p>
<p>もし「<code>x == null</code> の場合には、<code>x</code> を使用するコードは、何もしないべき」だと考えていたなら、そもそも <code>x</code> に <code>null</code> を設定するべきではありませんでした。なぜなら、 <strong><code>null</code> は「何もしない」を意味するものではない</strong> からです。本来の意図を正しく表現するには、<code>x</code> に「何もしないという挙動を持つインスタンス」を設定すべきなのです。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// X の派生クラスで、「何もしないという挙動」を持つもの</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NullX</span></span><br><span class="line">    : <span class="title">X</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SomeMethod</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// 何もしない。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>これがさきほどの <code>NullX</code> クラスです。名前に null とついてはいますが、<code>null</code> とは異なり、実体を持つ何かです。</p>
<h2 id="まとめ"><a href="#まとめ" class="headerlink" title="まとめ"></a>まとめ</h2><ul>
<li><strong>問題</strong>: <code>null</code> のメソッドを呼んでしまわないように、条件分岐を書きすぎたり書き忘れたりしてしまう。</li>
<li><strong>解決策</strong>: <code>null</code> を使わない。変数は適切なインスタンスで初期化する。</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="http://qiita.com/kasei-san/items/af10a948c34c317e7380" target="_blank" rel="noopener">NullObjectパターン - Qiita</a></p>
<p>  Ruby によるサンプルコードと、Nullオブジェクトパターンの参考になるリンクが記載されています。</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2016-08-18/null-object-patterns/" data-id="cjnspsyxm000kkfcx6h7358zu" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/オブジェクト指向/">オブジェクト指向</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/デザインパターン/">デザインパターン</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-package-management-with-paket-and-gist" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2016-05-10/package-management-with-paket-and-gist/" class="article-date">
  <time datetime="2016-05-09T15:00:00.000Z" itemprop="datePublished">2016-05-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/blog/2016-05-10/package-management-with-paket-and-gist/">PaketとGistで始める簡単パッケージ管理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="http://qiita.com/vain0x/items/41f13fed6f88be7f4e7e" target="_blank" rel="noopener">Qiita</a></p>
<p>対象読者: パッケージマネージャのないスクリプト言語のユーザー全般 (HSP3とか)</p>
<h2 id="導入"><a href="#導入" class="headerlink" title="導入"></a>導入</h2><p>モジュールと呼ばれるスクリプトは汎用的なため、使い回しが可能なわけですが、いかにして使い回すかはちょっとした問題です。<br>最初に思いつきそうな:</p>
<ul>
<li>スクリプトが必要になるたびに、ファイルをコピーを作成して使う。(コピペ法)</li>
</ul>
<p>という方法だと、例えばモジュールにバグがあった場合などにモジュールを書き換えた後、それらのコピーを上書きして回ることになります。<br>めんどうですね。</p>
<p>そのため:</p>
<ul>
<li>ファイルをまとめておいておき、それを直接 #include して使う。 (共有法)</li>
</ul>
<p>というようにしている人も少なくないでしょう。</p>
<p>しかし、これにも少し問題があります。<br>スクリプトを配布するときに、どのファイルが必要なのか分からなくなるのです。<br>単純に「#include されているファイル」を集めるだけでは、「あるモジュールが他のモジュールを使用している」といった状況には対処できません。</p>
<p>※不要なものも全部いっしょくたにして同梱してしまう、という富豪的な方法もあります。</p>
<h2 id="パッケージ管理ツール"><a href="#パッケージ管理ツール" class="headerlink" title="パッケージ管理ツール"></a>パッケージ管理ツール</h2><p>さて、私がおすすめするのは、パッケージ管理ツールと呼ばれるツールを使用することです。<br>ここでは <a href="http://fsprojects.github.io/Paket" target="_blank" rel="noopener">Paket</a> を利用します。</p>
<p>※Paket は HSPとは全く無関係な環境ために開発されているものですが、汎用的な機能を備えており、使うのがとても簡単なので、採用しています。</p>
<h2 id="Paket-をインストールする"><a href="#Paket-をインストールする" class="headerlink" title="Paket をインストールする"></a>Paket をインストールする</h2><p>まず始めに、ひとまとまりのソフトウェアのスクリプトを入れていくためのフォルダを1個作ります。<br>以下、このフォルダを <strong>ソリューションルート</strong> と呼びます。</p>
<p>次に、ソリューションルートに <code>.paket</code> という名前のフォルダを作ります。<br>(エクスプローラーでは、 <code>.paket.</code> という名前のフォルダを作ろうとすると、 <code>.paket</code> フォルダが作られます。興味深い。)<br>そこに、「<a href="https://github.com/fsprojects/Paket/releases/latest" target="_blank" rel="noopener">Paket の最新版</a>」から <code>paket.bootstrapper.exe</code> をダウンロードして配置し、実行します。<br>すると、最新版の <code>paket.exe</code> がダウンロードされます。<br>Paket のインストール作業はこれで完了です。簡単でしょう？</p>
<h2 id="モジュールを使用する"><a href="#モジュールを使用する" class="headerlink" title="モジュールを使用する"></a>モジュールを使用する</h2><p>スクリプトからモジュールを使用するときの作業を解説します。<br>例として、拙作の dirlist_rec モジュールをインストールしてみます。</p>
<blockquote>
<p><a href="https://gist.github.com/vain0x/561a66531363ab1e0e73" target="_blank" rel="noopener">https://gist.github.com/vain0x/561a66531363ab1e0e73</a></p>
</blockquote>
<p>ソリューションルートに、 <code>paket.dependencies</code> という名前のファイルを作り、次のように記述します。<br>(すでにある場合は書き足します。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gist vain0x/561a66531363ab1e0e73 dirlist_rec.hsp</span><br></pre></td></tr></table></figure>
<p>※真ん中にある「vain0x/英数字」は、URLの末尾です。</p>
<p><code>paket.dependencies</code> を更新したら、「paket install コマンド」を実行する必要があります。<br>そのためには、ソリューションルートをエクスプローラーで開き、「Shift キーを押しながら、ソリューションルートのフォルダを右クリック」して、「コマンドプロンプトを開く」メニューを選びます。<br>黒いコンソール画面が出てくるので、そこに次のように入力して enter を押します。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.paket\paket install</span><br></pre></td></tr></table></figure>
<p>すると、 <code>paket-files</code> フォルダの深いところに、 <code>dirlist_rec.hsp</code> がダウンロードされます。</p>
<p>モジュールを実際に使ってみましょう。<br>ソリューションルートの下に <code>app</code> フォルダを作り、そこに <code>main.hsp</code> ファイルを作成して、以下のように記述してみます。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;../paket-files/vain0x/561a66531363ab1e0e73/dirlist_rec.hsp&quot;</span><br><span class="line"></span><br><span class="line">  dirlist_rec paths, &quot;*.*&quot;</span><br><span class="line">  repeat stat</span><br><span class="line">    mes paths(cnt)</span><br><span class="line">  loop</span><br></pre></td></tr></table></figure>
<p>dirlist_rec モジュールが使えていますね。</p>
<h3 id="その他のコマンド"><a href="#その他のコマンド" class="headerlink" title="その他のコマンド"></a>その他のコマンド</h3><p>paket には install のほかにもたくさんコマンドがありますが、2つだけ紹介しておきます。<br>「.paket\paket update」を使うと、モジュールの最新版をダウンロードしてきます。<br>「.paket\paket outdated」を使うと、使用しているモジュールの、新しいバージョンがあるかを調べることができます。</p>
<h2 id="モジュールを公開する"><a href="#モジュールを公開する" class="headerlink" title="モジュールを公開する"></a>モジュールを公開する</h2><p>最後に、モジュールを公開する方法を説明します。<br>ここでは一番簡単な、Gist というウェブサイトを使用する方法をとります。</p>
<p>まず Github のアカウント(無料)を取得します。</p>
<blockquote>
<p><a href="https://github.com/" target="_blank" rel="noopener">https://github.com/</a></p>
</blockquote>
<p>ログインしてから、<a href="https://gist.github.com" target="_blank" rel="noopener">Gist</a> に行きます。<br>見て分かると思いますが、「Filename including extension…」と書かれた小さな入力欄に「ファイル名.hsp」を書き、大きいテキストボックスにスクリプトを貼り付けて、「Create secret/public gist」 を押せばアップロード完了です。</p>
<p>※secret gist で公開すると、検索にひっかからないので、URLを知っている人だけがアクセスできるようになります。</p>
<h2 id="モジュールの依存関係を記述する"><a href="#モジュールの依存関係を記述する" class="headerlink" title="モジュールの依存関係を記述する"></a>モジュールの依存関係を記述する</h2><p>モジュールが他のモジュールを使用している場合は、そのことを Paket に教えておくと便利です。<br>というのも、Paket はあるモジュールをダウンロードするとき、それが必要とする他のモジュールも一緒にダウンロードしてくれるのです。</p>
<p>そのためには、先ほどスクリプトを書いて公開した Gist のページに行き、「Edit」ボタンを押して編集画面を開き、「Add file」ボタンを押します。</p>
<p>新しいファイルには、やはり <code>paket.dependencies</code> という名前をつけて、上で例にあげたのと同様に「gist 誰々/英数字 ファイル名」などと書きます。<br>「Update」(更新)ボタンを押して保存するのを忘れませんよう。</p>
<p>こうしておけば前述の通り、そのモジュールが paket install される際に、<br>必要な他のモジュールも一緒にダウンロードされるようになります。</p>
<p>これが役に立つ場面もあることでしょう。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2016-05-10/package-management-with-paket-and-gist/" data-id="cjnspsyxk000ikfcxk7u767el" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/HSP/">HSP</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/Paket/">Paket</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/パッケージ管理/">パッケージ管理</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/blog/page/2/">&laquo; 前へ</a><a class="page-number" href="/blog/">1</a><a class="page-number" href="/blog/page/2/">2</a><span class="page-number current">3</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新記事</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019-01-05/lsp-trial-01/">LSP学習記 #1</a>
          </li>
        
          <li>
            <a href="/blog/2018-12-31/diary/">近況 2018-12-31</a>
          </li>
        
          <li>
            <a href="/blog/2018-12-16/siku-siku-primes/">シクシク素数列を F# でやってみた</a>
          </li>
        
          <li>
            <a href="/blog/2018-11-30/diary/">近況 2018-11-30</a>
          </li>
        
          <li>
            <a href="/blog/2018-11-07/pi-challenge/">円周率チャレンジにアルゴリズムでチャレンジ</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">タグクラウド</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/NET/" style="font-size: 12px;">.NET</a> <a href="/blog/tags/C/" style="font-size: 20px;">C#</a> <a href="/blog/tags/Essay/" style="font-size: 18px;">Essay</a> <a href="/blog/tags/F/" style="font-size: 16px;">F#</a> <a href="/blog/tags/Git/" style="font-size: 10px;">Git</a> <a href="/blog/tags/HSP/" style="font-size: 10px;">HSP</a> <a href="/blog/tags/Paket/" style="font-size: 10px;">Paket</a> <a href="/blog/tags/Prolog/" style="font-size: 10px;">Prolog</a> <a href="/blog/tags/Rust/" style="font-size: 14px;">Rust</a> <a href="/blog/tags/Tips/" style="font-size: 14px;">Tips</a> <a href="/blog/tags/WPF/" style="font-size: 14px;">WPF</a> <a href="/blog/tags/アルゴリズム/" style="font-size: 10px;">アルゴリズム</a> <a href="/blog/tags/オブジェクト指向/" style="font-size: 10px;">オブジェクト指向</a> <a href="/blog/tags/チュートリアル/" style="font-size: 10px;">チュートリアル</a> <a href="/blog/tags/テキストエディタ/" style="font-size: 10px;">テキストエディタ</a> <a href="/blog/tags/デザインパターン/" style="font-size: 10px;">デザインパターン</a> <a href="/blog/tags/データベース/" style="font-size: 10px;">データベース</a> <a href="/blog/tags/ネタ/" style="font-size: 10px;">ネタ</a> <a href="/blog/tags/バージョン管理/" style="font-size: 10px;">バージョン管理</a> <a href="/blog/tags/パッケージ管理/" style="font-size: 10px;">パッケージ管理</a> <a href="/blog/tags/プログラミング言語/" style="font-size: 12px;">プログラミング言語</a> <a href="/blog/tags/ユニットテスト/" style="font-size: 10px;">ユニットテスト</a> <a href="/blog/tags/印刷/" style="font-size: 10px;">印刷</a> <a href="/blog/tags/日記/" style="font-size: 18px;">日記</a> <a href="/blog/tags/競技プログラミング/" style="font-size: 12px;">競技プログラミング</a> <a href="/blog/tags/言語実装/" style="font-size: 12px;">言語実装</a> <a href="/blog/tags/関数型プログラミング/" style="font-size: 10px;">関数型プログラミング</a> <a href="/blog/tags/非同期/" style="font-size: 14px;">非同期</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 vain0x<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">ブログ</a>
  
    <a href="/blog/archives" class="mobile-nav-link">記事一覧</a>
  
    <a href="https://note.mu/vain0x/m/m9aa8513f4e97" class="mobile-nav-link">競プロ参戦記</a>
  
    <a href="https://qiita.com/vain0x" class="mobile-nav-link">Qiita</a>
  
    <a href="https://github.com/vain0x" class="mobile-nav-link">GitHub</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>