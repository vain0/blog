<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-128265968-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->


  
  <title>LSP学習記 #3 シンボルとハイライト | vain0x&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="自作言語の LSP サーバーを作るプロジェクトの第3回です。今回はシンボルテーブルを作ってシンボルのハイライト機能を実装します。  初回: LSP学習記 #1 前回: LSP学習記 #2 クラゲ言語の構文解析 今回のソースコード: curage-lang v0.4.0  let文とシャドーイング前回構文を定義したように、 クラゲ言語 (curage-lang) のプログラムは let 文の繰り返し">
<meta name="keywords" content="言語処理系,TypeScript,LanguageServerProtocol,LSP学習記">
<meta property="og:type" content="article">
<meta property="og:title" content="LSP学習記 #3 シンボルとハイライト">
<meta property="og:url" content="http://vain0x.github.io/blog/2019-01-10/lsp-trial-03/index.html">
<meta property="og:site_name" content="vain0x&#39;s blog">
<meta property="og:description" content="自作言語の LSP サーバーを作るプロジェクトの第3回です。今回はシンボルテーブルを作ってシンボルのハイライト機能を実装します。  初回: LSP学習記 #1 前回: LSP学習記 #2 クラゲ言語の構文解析 今回のソースコード: curage-lang v0.4.0  let文とシャドーイング前回構文を定義したように、 クラゲ言語 (curage-lang) のプログラムは let 文の繰り返し">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://qiita-image-store.s3.amazonaws.com/0/74340/d9da9328-5a47-49b1-0a39-784fab38a091.png">
<meta property="og:updated_time" content="2019-02-26T13:37:35.337Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="LSP学習記 #3 シンボルとハイライト">
<meta name="twitter:description" content="自作言語の LSP サーバーを作るプロジェクトの第3回です。今回はシンボルテーブルを作ってシンボルのハイライト機能を実装します。  初回: LSP学習記 #1 前回: LSP学習記 #2 クラゲ言語の構文解析 今回のソースコード: curage-lang v0.4.0  let文とシャドーイング前回構文を定義したように、 クラゲ言語 (curage-lang) のプログラムは let 文の繰り返し">
<meta name="twitter:image" content="https://qiita-image-store.s3.amazonaws.com/0/74340/d9da9328-5a47-49b1-0a39-784fab38a091.png">
<meta name="twitter:creator" content="@vain0x">
  
    <link rel="alternate" href="/blog/atom.xml" title="vain0x&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/blog/favicon.jpg">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/blog/css/style.css">
  <link href="https://fonts.googleapis.com/css?family=Noto+Sans+JP:400,700&amp;subset=japanese" rel="stylesheet">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">vain0x&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="https://vain0x.github.io">ホーム</a>
        
          <a class="main-nav-link" href="/blog/">ブログ</a>
        
          <a class="main-nav-link" href="/blog/archives">記事一覧</a>
        
          <a class="main-nav-link" href="https://note.mu/vain0x/m/m9aa8513f4e97">競プロ参戦記</a>
        
          <a class="main-nav-link" href="https://qiita.com/vain0x">Qiita</a>
        
          <a class="main-nav-link" href="https://github.com/vain0x">GitHub</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSSフィード"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="検索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://vain0x.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-lsp-trial-03" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2019-01-10/lsp-trial-03/" class="article-date">
  <time datetime="2019-01-10T13:12:00.000Z" itemprop="datePublished">2019-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      LSP学習記 #3 シンボルとハイライト
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>自作言語の LSP サーバーを作るプロジェクトの第3回です。今回はシンボルテーブルを作ってシンボルのハイライト機能を実装します。</p>
<ul>
<li>初回: <a href="https://vain0x.github.io/blog/2019-01-05/lsp-trial-01/">LSP学習記 #1</a></li>
<li>前回: <a href="https://vain0x.github.io/blog/2019-01-07/lsp-trial-02/">LSP学習記 #2 クラゲ言語の構文解析</a></li>
<li>今回のソースコード: <a href="https://github.com/vain0x/curage-lang/tree/v0.4.0" target="_blank" rel="noopener">curage-lang v0.4.0</a></li>
</ul>
<h2 id="let文とシャドーイング"><a href="#let文とシャドーイング" class="headerlink" title="let文とシャドーイング"></a>let文とシャドーイング</h2><p>前回構文を定義したように、 <strong>クラゲ言語</strong> (curage-lang) のプログラムは <code>let</code> 文の繰り返しです。</p>
<p>クラゲ言語の <code>let</code> はローカル変数を作るものですが、TypeScript の <code>let</code> とやや異なる性質を持つように定めます。その性質とは、「シャドーイング」です。例えば、次のコードを実行すると <code>y</code> の値は <code>2</code> になります。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let x be 1</span><br><span class="line">let x be 2</span><br><span class="line">let y be x</span><br></pre></td></tr></table></figure>
<p>このコードは <code>x</code> という名前の変数を2つ定義します。2つ目の <code>x</code> が定義された時点で、1つ目の <code>x</code> を使える範囲が終了します。TypeScript でいうと次のような感じです。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">const</span> x = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">const</span> y = x;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>シャドーイングがあるといろいろ便利なんですが、今回はひとまず、連載の進行をスムーズにするために入れます。</p>
<h2 id="シンボルとハイライト"><a href="#シンボルとハイライト" class="headerlink" title="シンボルとハイライト"></a>シンボルとハイライト</h2><p>上記のクラゲ言語のコードで、<code>x</code> という名前は3回出現します。1回目と2回目が別の変数を指す一方で、2回目と3回目は同じ変数を指します。</p>
<p>「同じ変数を指しているかどうか」でグループ分けすると便利です。同じ変数を指す名前は、同じ <strong>シンボル</strong> であると呼ぶことにします。</p>
<p>どれとどれが同じシンボルなのか、分かりやすく表示されると嬉しいです。</p>
<p>おそらくこの用途を想定して、エディターにソースコードの一部をハイライトしてもらえる機能が LSP にあります。今回の主役、 <a href="https://microsoft.github.io/language-server-protocol/specification#textDocument_documentHighlight" target="_blank" rel="noopener"><code>textDocument/documentHighlight</code> リクエスト</a>  です。</p>
<p>LSP クライアントは、サーバーに <code>documentHighlight</code> リクエストを送ってハイライトすべき場所を尋ねます。LSP の上ではカーソルという概念は出現しませんが、少なくとも VSCode や Sublime Text はカーソルの位置を指定してこのリクエストを送ってくれるようです。</p>
<ul>
<li>注: <code>textDocument/documentHighlight</code> リクエストが来るのは LSP サーバーがこの機能に対応している場合のみです。<code>initialize</code> レスポンスに指定する <code>capabilities</code> に設定が必要です。(詳細は実際のコードを参照)</li>
</ul>
<p>言葉で説明してもアレなので、今回の動作例を先に貼ります:</p>
<p><img src="https://qiita-image-store.s3.amazonaws.com/0/74340/d9da9328-5a47-49b1-0a39-784fab38a091.png" alt></p>
<p>(カーソル上にある <code>x</code> と、同じ変数を指す <code>x</code> がすべてハイライトされているが、他の変数はハイライトされていない、という状況)</p>
<p>カーソル位置にある名前が指しているシンボルと同一のシンボルをハイライトさせる。これが今回の目標です。</p>
<h2 id="実装"><a href="#実装" class="headerlink" title="実装"></a>実装</h2><p>そういうわけで、ソースコード上の名前がどのシンボルに対応するのかを調べる処理を書きます。</p>
<p>クラゲ言語の構文をとてもシンプルにしているおかげで、実装もシンプルに済みます。</p>
<p>前回の構文解析で得られた <code>let</code> 文のリストを順にみていき、文中に出現している「名前」(トークン)の情報を記録していく、というのが大まかな流れです。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> statement of statements) &#123;</span><br><span class="line">  <span class="keyword">if</span> (statement.type === <span class="string">"let"</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; init, name &#125; = statement</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (init.type === <span class="string">"name"</span>) &#123;</span><br><span class="line">      referName(init)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (name.type === <span class="string">"name"</span>) &#123;</span><br><span class="line">      defineName(name)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"NEVER"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ある名前が変数を参照している (= 式として出現している) のか、変数を定義している (= <code>be</code> の左辺に出現している) のか、というのを文脈から判別しています。</p>
<ul>
<li>余談: いまのクラゲ言語は非現実的なほど簡素ですが、仮にループ構文や足し算などがあったとしても、実装の基本的な考えは変わらないはずです。</li>
</ul>
<h3 id="実装-シンボルテーブルと環境"><a href="#実装-シンボルテーブルと環境" class="headerlink" title="実装: シンボルテーブルと環境"></a>実装: シンボルテーブルと環境</h3><p>シンボルが持つべき情報は何でしょうか。それがどこで定義されたのかと、どこで使われたのか、です。これをほぼそのまま型定義にしたのが、次の <code>SymbolDefinition</code> です:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> SymbolDefinition &#123;</span><br><span class="line">  <span class="comment">/** このシンボルを定義したトークン */</span></span><br><span class="line">  definition: Token,</span><br><span class="line">  <span class="comment">/** シンボルを参照するトークンの集まり */</span></span><br><span class="line">  references: Token[],</span><br><span class="line">  <span class="comment">/** このシンボルの種類。いまは変数だけ */</span></span><br><span class="line">  <span class="keyword">type</span>: <span class="string">"var"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>もう1つ必要なものがあって、名前からシンボル定義へのマップ <code>environment</code> です。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> environment = <span class="keyword">new</span> Map&lt;<span class="built_in">string</span>, SymbolDefinition&gt;()</span><br></pre></td></tr></table></figure>
<p>何らかの変数を参照している名前をみつけたときに、それが実際に指しているシンボルを特定するのに使います。例えば次の処理、「式」として名前が出現したときの処理です:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> referName = <span class="function">(<span class="params">nameToken: Token</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> symbolDefinition = environment.get(nameToken.value)</span><br><span class="line">  <span class="keyword">if</span> (!symbolDefinition) <span class="keyword">return</span> <span class="comment">// ここで未定義変数の警告を出してもいい</span></span><br><span class="line"></span><br><span class="line">  symbolDefinition.references.push(nameToken)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一方で、変数として定義される名前をみつけたときは、環境に名前を追加します。ここで、同名の変数がすでに環境にあるときは「上書き」されますが、それがまさに冒頭に書いた「シャドーイング」の挙動なのでOKです。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defineName = <span class="function">(<span class="params">nameToken: Token</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> definition: SymbolDefinition = &#123;</span><br><span class="line">    <span class="keyword">type</span>: <span class="string">"var"</span>,</span><br><span class="line">    definition: nameToken, <span class="comment">// 定義位置を記録</span></span><br><span class="line">    references: [],</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  symbolDefinitions.push(definition) <span class="comment">// 新しいシンボル</span></span><br><span class="line">  environment.set(nameToken.value, definition) <span class="comment">// 同名の変数は上書き</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>そして解析が完了したあと、最終的に環境は捨てて、シンボル定義のリスト (シンボルテーブル) を解析結果とします。解析結果は繰り返し使うので、 <code>SemanticModel</code> という名前のインターフェイスを定義しました。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123; statements, symbolDefinitions, diagnostics &#125; <span class="keyword">as</span> SemanticModel</span><br></pre></td></tr></table></figure>
<ul>
<li><p><a href="https://github.com/vain0x/curage-lang/commit/8dda6a9798fefd6cb4507615ae6f5fe05ff76068" target="_blank" rel="noopener">変更点まとめ</a></p>
</li>
<li><p>余談: 環境をマップとして定義するのではなく、単に新しいシンボルから順番に名前を調べて探す実装にしたほうが話が早かった気もします。</p>
</li>
</ul>
<h3 id="実装-位置とヒットテスト"><a href="#実装-位置とヒットテスト" class="headerlink" title="実装: 位置とヒットテスト"></a>実装: 位置とヒットテスト</h3><p><code>textDocument/documentHighlight</code> リクエストは、カーソルがある位置の変数の名前ではなく、カーソルの位置 (ソースコード上の位置) しか教えてくれません。その位置に何があるかはサーバー側で調べる必要があります。</p>
<p>カーソル上の位置にあるシンボルを調べる処理を、シンボルのヒットテストと呼ぶことにします。これはトークンの位置情報を使うと可能です。シンボル定義の <code>definition</code> や <code>references</code> のトークンのどれかがカーソルにかすっていたら、カーソル上にそのシンボルがあるということです。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hitTestSymbol = <span class="function">(<span class="params">semanticModel: SemanticModel, position: Position</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 範囲が指定位置にかすってるかどうか</span></span><br><span class="line">  <span class="keyword">const</span> touch = <span class="function">(<span class="params">range: Range</span>) =&gt;</span></span><br><span class="line">    comparePositions(range.start, position) &lt;= <span class="number">0</span></span><br><span class="line">    &amp;&amp; comparePositions(position, range.end) &lt;= <span class="number">0</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> symbolDefinition of semanticModel.symbolDefinitions) &#123;</span><br><span class="line">    <span class="keyword">if</span> (touch(symbolDefinition.definition.range)) &#123;</span><br><span class="line">      <span class="keyword">return</span> symbolDefinition</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> r of symbolDefinition.references) &#123;</span><br><span class="line">      <span class="keyword">if</span> (touch(r.range)) &#123;</span><br><span class="line">        <span class="keyword">return</span> symbolDefinition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>touch</code> 関数で使っている、位置の大小関係 (前後関係) の比較関数は次のとおりです。もし2つの位置の行番号が違えば、行番号の大小関係がそのまま前後関係です。逆に行番号が同じなら、列の大小関係が前後関係になります。要するに辞書式順序。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> comparePositions = <span class="function">(<span class="params">l: Position, r: Position</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (l.line !== r.line) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sign(l.line - r.line)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.sign(l.character - r.character)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/vain0x/curage-lang/commit/1e7cc2d5e9e0431525fa50d60def089424a7e882" target="_blank" rel="noopener">変更点まとめ</a></li>
</ul>
<h3 id="実装-解析結果の保存"><a href="#実装-解析結果の保存" class="headerlink" title="実装: 解析結果の保存"></a>実装: 解析結果の保存</h3><p><code>textDocument/documentHighlight</code> リクエストは、解析対象のドキュメントを URI で指定します。ソースコード本体は、 <code>textDocument/didOpen</code> や <code>didChange</code> で通知されたときのものを記録して、参照することになります。</p>
<p>それらのタイミングで構文解析や上述の解析を行い、その結果をマップか何かに保存しましょう。</p>
<ul>
<li><a href="https://github.com/vain0x/curage-lang/commit/2c72aa786af0f0e649319a111ac1d17c927d6a33" target="_blank" rel="noopener">変更点まとめ</a></li>
<li>注: ファイルが閉じられたときの <code>didClose</code> イベントをフックして、マップからエントリーを削除することで、メモリーリークを防ぎます。</li>
</ul>
<h3 id="実装-ハイライトの生成"><a href="#実装-ハイライトの生成" class="headerlink" title="実装: ハイライトの生成"></a>実装: ハイライトの生成</h3><p>最後に <code>textDocument/documentHighlight</code> へのレスポンスを生成します。ドキュメントをハイライトすべき範囲と、そのハイライトの種類 (定義部分なのか参照部分なのか) というのを指定した <code>DocumentHighlight</code> のリストを作ればOK。</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> DocumentHighlight &#123;</span><br><span class="line">    <span class="comment">/** ハイライトする範囲 */</span></span><br><span class="line">    range: Range;</span><br><span class="line">    <span class="comment">/** ハイライトの種類 (DocumentHighlightKind) */</span></span><br><span class="line">    kind?: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>これはヒットテストで得られたシンボル定義の <code>definition</code> と <code>references</code> を適当に変形すればOK。すでに手札は揃っているという感じですね。</p>
<p>要点だけ抜粋するとこんな感じ:</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> highlights: DocumentHighlight[] = []</span><br><span class="line"><span class="keyword">const</span> &#123; definition, references &#125; = symbolDefinition <span class="comment">// ヒットしたシンボル定義</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定義位置をハイライト</span></span><br><span class="line">highlights.push(&#123;</span><br><span class="line">  kind: DocumentHighlightKind.Write,</span><br><span class="line">  range: definition.range,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> r of references) &#123;</span><br><span class="line">  <span class="comment">// 参照位置をハイライト</span></span><br><span class="line">  highlights.push(&#123;</span><br><span class="line">    kind: DocumentHighlightKind.Read,</span><br><span class="line">    range: r.range,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> highlights</span><br></pre></td></tr></table></figure>
<ul>
<li><a href="https://github.com/vain0x/curage-lang/commit/ac63c6b0e0f00c55096a48920e9957821b5a1549" target="_blank" rel="noopener">変更点まとめ</a></li>
</ul>
<h2 id="動作確認"><a href="#動作確認" class="headerlink" title="動作確認"></a>動作確認</h2><p>冒頭に貼ったスクリーンショットが動作例になります。</p>
<h2 id="まとめと次回"><a href="#まとめと次回" class="headerlink" title="まとめと次回"></a>まとめと次回</h2><p>今回のポイントは以下の3点でした。</p>
<ul>
<li>シンボルを静的解析した</li>
<li>ヒットテストを実装した</li>
<li>格好よくハイライトできて嬉しい</li>
</ul>
<p>次は、用意したシンボルテーブルをさらに活用して、「名前の変更」を実装します。</p>
<ul>
<li>次回: <a href="https://vain0x.github.io/blog/2019-01-16/lsp-trial-04/">LSP学習記 #4 シンボルのリネーム</a></li>
</ul>
<h2 id="余談-シンボル参照の検索について"><a href="#余談-シンボル参照の検索について" class="headerlink" title="余談: シンボル参照の検索について"></a>余談: シンボル参照の検索について</h2><p>今回のシンボルテーブルを使うことで、 <code>textDocument/definition</code> (定義へのジャンプ) と <code>textDocument/references</code> (シンボルの検索) は簡単に実装できると思います。やってみましょう！</p>
<h2 id="余談-用語について"><a href="#余談-用語について" class="headerlink" title="余談: 用語について"></a>余談: 用語について</h2><ul>
<li>シンボル (symbol) やセマンティックモデル (semantic model) などの用語は Roslyn API (C#コンパイラ) を参考にしています。</li>
<li>ヒットテストは「マウスカーソルでクリックしたとき、それがボタンに当たったかどうかを判定する」といった状況で使う動詞なので、今回の用途は微妙かもしれません。</li>
<li>「環境」や「シンボルテーブル」といった概念は言語処理系の入門書によく出てきます。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://vain0x.github.io/blog/2019-01-10/lsp-trial-03/" data-id="cjslt6g85000a5vcxoesel785" class="article-share-link">共有</a>
      
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/LSP学習記/">LSP学習記</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/LanguageServerProtocol/">LanguageServerProtocol</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/TypeScript/">TypeScript</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/blog/tags/言語処理系/">言語処理系</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2019-01-16/lsp-trial-04/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">新しい記事へ</strong>
      <div class="article-nav-title">
        
          LSP学習記 #4 シンボルのリネーム
        
      </div>
    </a>
  
  
    <a href="/blog/2019-01-07/lsp-trial-02/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">古い記事へ</strong>
      <div class="article-nav-title">LSP学習記 #2 クラゲ言語の構文解析</div>
    </a>
  
</nav>

  
</article>




<section id="comments">
  <script src="https://utteranc.es/client.js" repo="vain0x/blog" issue-term="pathname" theme="github-light" crossorigin="anonymous" async>
  </script>
</section>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新記事</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2019-05-31/diary/">近況 2019-05-31</a>
          </li>
        
          <li>
            <a href="/blog/2019-04-30/diary/">近況 2019-04-30</a>
          </li>
        
          <li>
            <a href="/blog/2019-03-31/diary/">近況 2019-03-31</a>
          </li>
        
          <li>
            <a href="/blog/2019-02-27/diary/">近況 2019-02-27</a>
          </li>
        
          <li>
            <a href="/blog/2019-02-26/interpreter-written-in-hsp3/">HSP3 でスクリプト言語の処理系を書く</a>
          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">タグクラウド</h3>
    <div class="widget tagcloud">
      <a href="/blog/tags/NET/" style="font-size: 11.67px;">.NET</a> <a href="/blog/tags/C/" style="font-size: 20px;">C#</a> <a href="/blog/tags/Essay/" style="font-size: 16.67px;">Essay</a> <a href="/blog/tags/F/" style="font-size: 15px;">F#</a> <a href="/blog/tags/Git/" style="font-size: 10px;">Git</a> <a href="/blog/tags/HSP/" style="font-size: 10px;">HSP</a> <a href="/blog/tags/HSP3/" style="font-size: 10px;">HSP3</a> <a href="/blog/tags/LSP学習記/" style="font-size: 15px;">LSP学習記</a> <a href="/blog/tags/LanguageServerProtocol/" style="font-size: 15px;">LanguageServerProtocol</a> <a href="/blog/tags/Paket/" style="font-size: 10px;">Paket</a> <a href="/blog/tags/Prolog/" style="font-size: 10px;">Prolog</a> <a href="/blog/tags/Rust/" style="font-size: 13.33px;">Rust</a> <a href="/blog/tags/Tips/" style="font-size: 13.33px;">Tips</a> <a href="/blog/tags/TypeScript/" style="font-size: 15px;">TypeScript</a> <a href="/blog/tags/WPF/" style="font-size: 13.33px;">WPF</a> <a href="/blog/tags/アルゴリズム/" style="font-size: 10px;">アルゴリズム</a> <a href="/blog/tags/オブジェクト指向/" style="font-size: 10px;">オブジェクト指向</a> <a href="/blog/tags/チュートリアル/" style="font-size: 10px;">チュートリアル</a> <a href="/blog/tags/テキストエディタ/" style="font-size: 10px;">テキストエディタ</a> <a href="/blog/tags/デザインパターン/" style="font-size: 10px;">デザインパターン</a> <a href="/blog/tags/データベース/" style="font-size: 10px;">データベース</a> <a href="/blog/tags/ネタ/" style="font-size: 10px;">ネタ</a> <a href="/blog/tags/バージョン管理/" style="font-size: 10px;">バージョン管理</a> <a href="/blog/tags/パッケージ管理/" style="font-size: 10px;">パッケージ管理</a> <a href="/blog/tags/プログラミング言語/" style="font-size: 11.67px;">プログラミング言語</a> <a href="/blog/tags/ユニットテスト/" style="font-size: 10px;">ユニットテスト</a> <a href="/blog/tags/印刷/" style="font-size: 10px;">印刷</a> <a href="/blog/tags/日記/" style="font-size: 20px;">日記</a> <a href="/blog/tags/競技プログラミング/" style="font-size: 11.67px;">競技プログラミング</a> <a href="/blog/tags/言語処理系/" style="font-size: 18.33px;">言語処理系</a> <a href="/blog/tags/関数型プログラミング/" style="font-size: 10px;">関数型プログラミング</a> <a href="/blog/tags/非同期/" style="font-size: 13.33px;">非同期</a>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 vain0x<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="https://vain0x.github.io" class="mobile-nav-link">ホーム</a>
  
    <a href="/blog/" class="mobile-nav-link">ブログ</a>
  
    <a href="/blog/archives" class="mobile-nav-link">記事一覧</a>
  
    <a href="https://note.mu/vain0x/m/m9aa8513f4e97" class="mobile-nav-link">競プロ参戦記</a>
  
    <a href="https://qiita.com/vain0x" class="mobile-nav-link">Qiita</a>
  
    <a href="https://github.com/vain0x" class="mobile-nav-link">GitHub</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">
  <script src="/blog/fancybox/jquery.fancybox.pack.js"></script>


<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>